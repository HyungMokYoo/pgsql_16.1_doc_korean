<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>30.1. 신뢰성</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="wal.html" title="Chapter 30. Reliability and the Write-Ahead Log" /><link rel="next" href="checksums.html" title="30.2. Data Checksums" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">30.1. 신뢰성</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="wal.html" title="Chapter 30. Reliability and the Write-Ahead Log">이전</a> </td><td width="10%" align="left"><a accesskey="u" href="wal.html" title="Chapter 30. Reliability and the Write-Ahead Log">Up</a></td><th width="60%" align="center">30장. 안정성과 미리 쓰기 로그</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="10%" align="right"> <a accesskey="n" href="checksums.html" title="30.2. Data Checksums">다음</a></td></tr></table><hr /></div><div class="sect1" id="WAL-RELIABILITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">30.1. 신뢰성 <a href="#WAL-RELIABILITY" class="id_link">#</a></h2></div></div></div><p>
   안정성은 모든 중요한 데이터베이스 시스템의 중요한 속성이며, <span class="productname">PostgreSQL은</span> 안정적인 작동을 보장하기 위해 가능한 모든 조치를 취합니다. 안정적인 작동의 한 측면은 커밋된 트랜잭션에 의해 기록된 모든 데이터가 전원 손실, 운영 체제 장애 및 하드웨어 장애로부터 안전한 비휘발성 영역에 저장되어야 한다는 것입니다(물론 비휘발성 영역 자체의 장애는 제외).  일반적으로 컴퓨터의 영구 저장소(디스크 드라이브 또는 이와 동등한 것)에 데이터를 성공적으로 쓰면 이 요건을 충족합니다.  실제로 컴퓨터가 치명적으로 손상되더라도 디스크 드라이브가 살아남는다면 유사한 하드웨어를 갖춘 다른 컴퓨터로 옮길 수 있으며 커밋된 모든 트랜잭션은 그대로 유지됩니다.  </p><p>
   주기적으로 디스크 플래터에 데이터를 강제로 옮기는 것은 간단한 작업처럼 보일 수 있지만, 그렇지 않습니다. 디스크 드라이브는 주 메모리와 CPU보다 훨씬 느리기 때문에 컴퓨터의 주 메모리와 디스크 플래터 사이에는 여러 계층의 캐싱이 존재합니다. 먼저, 자주 요청되는 디스크 블록을 캐싱하고 디스크 쓰기를 결합하는 운영 체제의 버퍼 캐시가 있습니다. 다행히도 모든 운영 체제는 애플리케이션에 버퍼 캐시에서 디스크로 강제 쓰기를 수행할 수 있는 방법을 제공하며, <span class="productname">PostgreSQL은</span> 이러한 기능을 사용합니다.  (이 작업을 수행하는 방법을 조정하려면 <a class="xref" href="runtime-config-wal.html#GUC-WAL-SYNC-METHOD">wal_sync_method</a> 매개 변수를 참조하세요.)  </p><p>
   다음으로, 디스크 드라이브 컨트롤러에 캐시가 있을 수 있으며, 이는 특히 <acronym class="acronym">RAID</acronym> 컨트롤러 카드에서 흔히 볼 수 있습니다. 이러한 캐시 중 일부는 쓰기 <em class="firstterm">스루</em> 방식으로, 쓰기가 도착하는 즉시 드라이브에 전송됩니다. 다른 캐시는 쓰기 후 다시 <em class="firstterm">쓰기</em> 방식으로, 데이터가 나중에 드라이브에 전송됩니다. 이러한 캐시는 디스크 컨트롤러 캐시의 메모리가 휘발성이므로 정전이 발생하면 그 내용을 잃을 수 있기 때문에 안정성에 위험이 될 수 있습니다.  더 나은 컨트롤러 카드에는 <em class="firstterm">배터리 백업 장치</em><acronym class="acronym">(BBU)</acronym>가 있어 시스템 전원 손실 시에도 캐시에 전원을 공급하는 배터리가 카드에 있습니다.  전원이 복구되면 데이터가 디스크 드라이브에 기록됩니다.  </p><p>
   마지막으로, 대부분의 디스크 드라이브에는 캐시가 있습니다. 일부는 쓰기 방식이고 일부는 쓰기-백 방식이며, 쓰기-백 드라이브 캐시도 디스크 컨트롤러 캐시와 마찬가지로 데이터 손실에 대한 우려가 존재합니다.  특히 소비자용 IDE 및 SATA 드라이브에는 정전 시에도 살아남지 못하는 쓰기-백 캐시가 있을 가능성이 높습니다.  많은 SSD(솔리드 스테이트 드라이브)에도 휘발성 쓰기-백 캐시가 있습니다.  </p><p>
   이러한 캐시는 일반적으로 비활성화할 수 있지만, 비활성화하는 방법은 운영 체제와 드라이브 유형에 따라 다릅니다:  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
       <span class="productname">Linux에서</span> IDE 및 SATA 드라이브는 <code class="command">hdparm -I를</code> 사용하여 쿼리할 수 있으며, 쓰기 <code class="literal">캐시</code> 옆에 <code class="literal">*가</code> 있으면 쓰기 캐시가 활성화되어 있습니다. 쓰기 캐시를 끄려면 <code class="command">hdparm -W 0을</code>사용할 수 있습니다.  쓰기 캐시가 활성화되어 있는지 확인하려면 <a class="ulink" href="http://sg.danny.cz/sg/sdparm.html" target="_top"><span class="application">sdparm</span></a> <code class="command">--get=WCE를</code> 사용하고, 비활성화하려면 <code class="command">sdparm --clear=WCE를</code>사용합니다.      </p></li><li class="listitem"><p>
       <span class="productname">FreeBSD에서</span> IDE 드라이브는 <code class="command">캠컨트롤 식별을</code> 사용하여 쿼리하고 <code class="filename">/boot/loader.conf에서</code> <code class="literal">hw.ata.wc=0을</code> 사용하여 쓰기 캐시를 해제할 수 있으며, SCSI 드라이브는 <code class="command">캠컨트롤 식별을</code> 사용하여 쿼리하고 사용 가능한 경우 <code class="command">sdparm을</code> 사용하여 쓰기 캐시를 모두 쿼리 및 변경할 수 있습니다.      </p></li><li class="listitem"><p>
       <span class="productname">Solaris에서</span> 디스크 쓰기 캐시는 <code class="command">format -e로</code> 제어됩니다. (Solaris <acronym class="acronym">ZFS</acronym> 파일 시스템은 자체 디스크 캐시 플러시 명령을 실행하므로 디스크 쓰기 캐시를 활성화해도 안전합니다.)      </p></li><li class="listitem"><p>
       <span class="productname">Windows에서</span> <code class="varname">wal_sync_method가</code> <code class="literal">open_datasync</code> (기본값)인 경우 <code class="literal">내 컴퓨터\열기\디스크<em class="replaceable"><code>드라이브\속성\하드웨어\속성\정책\디스크에 쓰기 캐싱 사용의</code></em></code> 선택을 취소하여 쓰기 캐싱을 사용하지 않도록 설정할 수 있습니다. 또는 <code class="varname">wal_sync_method를</code> <code class="literal">fdatasync</code> (NTFS 전용), <code class="literal">fsync</code> 또는 <code class="literal">fsync_writethrough로</code> 설정하면 쓰기 캐싱을 사용하지 않도록 할 수 있습니다.      </p></li><li class="listitem"><p>
       <span class="productname">macOS에서는</span> <code class="varname">wal_sync_method를</code> <code class="literal">fsync_writethrough로</code> 설정하여 쓰기 캐싱을 방지할 수 있습니다.      </p></li></ul></div><p>
   최신 SATA 드라이브( <acronym class="acronym">ATAPI-6</acronym> 이후 버전)는 드라이브 캐시 플러시 명령<code class="command">(FLUSH CACHE EXT</code>)을 제공하며, SCSI 드라이브는 오랫동안 유사한 명령인 <code class="command">SYNCHRONIZE CACHE를</code> 지원해 왔습니다.  이러한 명령은 <span class="productname">PostgreSQL에서</span> 직접 액세스할 수 없지만, 일부 파일 시스템(예: <acronym class="acronym">ZFS</acronym>, <acronym class="acronym">ext4</acronym>)에서는 쓰기 백 지원 드라이브의 플래터에 데이터를 플러시하는 데 사용할 수 있습니다.  안타깝게도 이러한 파일 시스템은 배터리 백업 장치(<acronym class="acronym">BBU</acronym>) 디스크 컨트롤러와 함께 사용하면 최적이 아닌 방식으로 작동합니다.  이러한 설정에서 동기화 명령은 컨트롤러 캐시의 모든 데이터를 강제로 디스크로 전송하므로 BBU의 이점을 대부분 제거합니다. <a class="xref" href="pgtestfsync.html" title="pg_test_fsync"><span class="refentrytitle"><span class="application">pg_test_fsync</span></span></a> 프로그램을 실행하여 영향을 받는지 확인할 수 있습니다.  영향을 받는 경우, 파일 시스템에서 쓰기 차단을 해제하거나 디스크 컨트롤러를 재구성하여 BBU의 성능 이점을 다시 얻을 수 있습니다(옵션인 경우).  쓰기 차단을 해제하는 경우 배터리가 계속 작동하는지 확인하세요. 배터리 결함으로 인해 데이터가 손실될 수 있습니다. 파일 시스템 및 디스크 컨트롤러 설계자가 이 최적이 아닌 동작을 해결할 수 있기를 바랍니다.  </p><p>
   운영 체제가 스토리지 하드웨어에 쓰기 요청을 보낼 때, 데이터가 진정한 비휘발성 스토리지 영역에 도착했는지 확인하기 위해 할 수 있는 일은 거의 없습니다. 오히려 모든 스토리지 구성 요소가 데이터와 파일 시스템 메타데이터 모두에 대해 무결성을 보장하는지 확인하는 것은 관리자의 책임입니다. 배터리로 지원되지 않는 쓰기 캐시가 있는 디스크 컨트롤러는 피하세요. 드라이브가 종료되기 전에 데이터가 기록될지 보장할 수 없다면 드라이브 수준에서 쓰기 백 캐싱을 비활성화하세요. SSD를 사용하는 경우, 많은 SSD가 기본적으로 캐시 플러시 명령을 따르지 않습니다. <a class="ulink" href="https://brad.livejournal.com/2116715.html" target="_top"><code class="filename">diskchecker.pl을</code></a> 사용하여 안정적인 I/O 하위 시스템 동작을 테스트할 수 있습니다.  </p><p>
   데이터 손실의 또 다른 위험은 디스크 플래터 쓰기 작업 자체에서 발생할 수 있습니다. 디스크 플래터는 일반적으로 각각 512바이트의 섹터로 나뉩니다.  모든 물리적 읽기 또는 쓰기 작업은 전체 섹터를 처리합니다. 쓰기 요청이 드라이브에 도착하면 512바이트의 일부 배수<span class="productname">(</span> 일반적으로 한 번에 8192바이트 또는 16개의 섹터를 쓰는<span class="productname">PostgreSQL</span> )에 대한 것일 수 있으며, 쓰기 프로세스는 언제든지 전원 손실로 인해 실패하여 512바이트 섹터 중 일부는 쓰여지고 다른 일부는 쓰여지지 않을 수 있습니다.  이러한 장애를 방지하기 위해 <span class="productname">PostgreSQL은</span> 디스크의 실제 페이지를 수정하기 <span class="emphasis"><em>전에</em></span> 전체 페이지 이미지를 영구 WAL 스토리지에 주기적으로 씁니다. 이렇게 하면 충돌 복구 중에 <span class="productname">PostgreSQL은</span> 부분적으로 쓰여진 페이지를 WAL에서 복원할 수 있습니다.  부분 페이지 쓰기를 방지하는 파일 시스템 소프트웨어(예: ZFS)를 사용하는 경우 <a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a> 매개변수를 해제하여 이 페이지 이미징을 해제할 수 있습니다. BBU(배터리 백업 장치) 디스크 컨트롤러는 데이터가 BBU에 전체(8kB) 페이지로 쓰여지도록 보장하지 않는 한 부분 페이지 쓰기를 방지하지 않습니다.  </p><p>
   또한 <span class="productname">PostgreSQL은</span> 시간이 지남에 따라 하드웨어 오류 또는 미디어 오류로 인해 발생할 수 있는 저장 장치의 일부 데이터 손상(예: 가비지 데이터 읽기/쓰기)으로부터 보호합니다.   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      WAL 파일의 각 개별 레코드는 레코드 내용이 올바른지 확인할 수 있는 CRC-32(32비트) 검사로 보호됩니다. CRC 값은 각 WAL 레코드를 작성할 때 설정되며 충돌 복구, 아카이브 복구 및 복제 중에 확인됩니다.     </p></li><li class="listitem"><p>
      현재 데이터 페이지는 기본적으로 체크섬이 적용되지 않지만, WAL 레코드에 기록된 전체 페이지 이미지는 보호됩니다. 데이터 체크섬 활성화에 대한 자세한 내용은 <a class="link" href="app-initdb.html#APP-INITDB-DATA-CHECKSUMS"><span class="application">initdb를</span></a>참조하세요.     </p></li><li class="listitem"><p>
     <code class="filename">pg_xact</code>, <code class="filename">pg_subtrans</code>, <code class="filename">pg_multixact</code>, <code class="filename">pg_serial</code>, <code class="filename">pg_notify</code>, <code class="filename">pg_stat</code>, <code class="filename">pg_snapshots와</code> 같은 내부 데이터 구조는 직접 체크섬되지 않으며 전체 페이지 쓰기로 페이지가 보호되지도 않습니다. 그러나 이러한 데이터 구조가 영구적인 경우, 충돌 복구 시 최근 변경 사항을 정확하게 재구축할 수 있는 WAL 레코드가 기록되며, 이러한 WAL 레코드는 위에서 설명한 대로 보호됩니다.     </p></li><li class="listitem"><p>
     <code class="filename">pg_twophase의</code> 개별 상태 파일은 CRC-32로 보호됩니다.     </p></li><li class="listitem"><p>
      정렬, 구체화 및 중간 결과를 위한 대규모 SQL 쿼리에 사용되는 임시 데이터 파일은 현재 체크섬이 적용되지 않으며, 이러한 파일의 변경 사항에 대해 WAL 레코드가 기록되지 않습니다.     </p></li></ul></div><p>
  </p><p>
  <span class="productname">PostgreSQL은</span> 수정 가능한 메모리 오류로부터 보호하지 않으며, 업계 표준 ECC(오류 정정 코드) 또는 그 이상의 보호 기능을 사용하는 RAM을 사용하여 작동한다고 가정합니다.  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="wal.html" title="Chapter 30. Reliability and the Write-Ahead Log">이전</a> </td><td width="20%" align="center"><a accesskey="u" href="wal.html" title="Chapter 30. Reliability and the Write-Ahead Log">위로</a></td><td width="40%" align="right"> <a accesskey="n" href="checksums.html" title="30.2. Data Checksums">다음</a></td></tr><tr><td width="40%" align="left" valign="top">30장. 안정성과 미리 쓰기 로그 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="40%" align="right" valign="top"> 30.2. 데이터 체크섬</td></tr></table></div></body></html>