<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.14. JSON 유형</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="datatype-xml.html" title="8.13. XML Type" /><link rel="next" href="arrays.html" title="8.15. Arrays" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.14. <acronym class="acronym">JSON</acronym> 타입</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-xml.html" title="8.13. XML Type">이전</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Chapter 8. Data Types">Up</a></td><th width="60%" align="center">8장. 데이터 타입</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="10%" align="right"> <a accesskey="n" href="arrays.html" title="8.15. Arrays">다음</a></td></tr></table><hr /></div><div class="sect1" id="DATATYPE-JSON"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.14. <acronym class="acronym">JSON</acronym> 타입 <a href="#DATATYPE-JSON" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="datatype-json.html#JSON-KEYS-ELEMENTS">8.14.1. JSON 입력 및 출력 구문</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSON-DOC-DESIGN">8.14.2. JSON 문서 디자인하기</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSON-CONTAINMENT">8.14.3. <code class="type">jsonb</code> 포함 및 존재 여부</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSON-INDEXING">8.14.4. <code class="type">jsonb</code> 인덱싱</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSONB-SUBSCRIPTING">8.14.5. <code class="type">jsonb</code> 서브스크립션</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#DATATYPE-JSON-TRANSFORMS">8.14.6. 변환</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#DATATYPE-JSONPATH">8.14.7. jsonpath 유형</a></span></dt></dl></div><a id="id-1.5.7.22.2" class="indexterm"></a><a id="id-1.5.7.22.3" class="indexterm"></a><p>
  JSON 데이터 유형은 <a class="ulink" href="https://tools.ietf.org/html/rfc7159" target="_top">RFC 7159에</a> 지정된 대로 JSON(JavaScript 객체 표기법) 데이터를 저장하기 위한 것입니다. 이러한 데이터는 <code class="type">텍스트로도</code> 저장할 수 있지만 JSON 데이터 유형은 저장된 각 값이 JSON 규칙에 따라 유효하도록 강제할 수 있다는 장점이 있습니다.  또한 이러한 데이터 유형에 저장된 데이터에 사용할 수 있는 다양한 JSON 전용 함수와 연산자가 있습니다( <a class="xref" href="functions-json.html" title="9.16. JSON Functions and Operators">섹션 9.16</a> 참조). </p><p>
 <span class="productname">PostgreSQL은</span> JSON 데이터를 저장하기 위한 두 가지 유형, 즉 <code class="type">json과</code> <code class="type">jsonb를</code> 제공합니다. 이러한 데이터 유형에 대한 효율적인 쿼리 메커니즘을 구현하기 위해 <span class="productname">PostgreSQL은</span> <a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.7. jsonpath Type">섹션 8.14.7에</a> 설명된 <code class="type">jsonpath</code> 데이터 유형도 제공합니다. </p><p>
 <code class="type">json</code> 및 <code class="type">jsonb</code> 데이터 유형은 <span class="emphasis"><em>거의</em></span> 동일한 값 집합을 입력으로 받아들입니다.  실질적인 주요 차이점은 효율성입니다. <code class="type">json</code> 데이터 유형은 입력 텍스트의 정확한 복사본을 저장하므로 처리 함수가 실행할 때마다 다시 구문 분석해야 하는 반면, <code class="type">jsonb</code> 데이터는 분해된 이진 형식으로 저장되므로 변환 오버헤드가 추가되어 입력 속도가 약간 느리지만 다시 구문 분석할 필요가 없으므로 처리 속도가 훨씬 빠릅니다. 또한 <code class="type">jsonb는</code> 색인화를 지원하므로 상당한 이점이 될 수 있습니다. </p><p>
 <code class="type">json</code> 유형은 입력 텍스트의 정확한 사본을 저장하기 때문에 토큰 사이의 의미상 중요하지 않은 공백과 JSON 객체 내의 키 순서를 보존합니다. 또한 값 내의 JSON 객체에 동일한 키가 두 번 이상 포함된 경우 모든 키/값 쌍이 유지됩니다. (처리 함수는 마지막 값을 작동하는 값으로 간주합니다.) 반면 <code class="type">jsonb는</code> 공백을 보존하지 않고 객체 키의 순서도 보존하지 않으며 중복된 객체 키도 유지하지 않습니다.  입력에 중복된 키가 지정되면 마지막 값만 유지됩니다. </p><p>
  일반적으로 대부분의 애플리케이션은 객체 키의 순서에 대한 레거시 가정과 같은 매우 특수한 요구 사항이 없는 한 JSON 데이터를 <code class="type">jsonb로</code> 저장하는 것을 선호합니다. </p><p>
 <acronym class="acronym">RFC</acronym> 7159는 JSON 문자열을 UTF8로 인코딩해야 한다고 명시하고 있습니다. 따라서 데이터베이스 인코딩이 UTF8이 아닌 한 JSON 유형이 JSON 사양을 엄격하게 준수하는 것은 불가능합니다. 데이터베이스 인코딩으로 표현할 수 없는 문자를 직접 포함하려는 시도는 실패하며, 반대로 데이터베이스 인코딩으로 표현할 수 있지만 UTF8로 표현할 수 없는 문자는 허용됩니다. </p><p>
 <acronym class="acronym">RFC</acronym> 7159는 JSON 문자열에 <code class="literal"><em class="replaceable"><code>\uXXXX로</code></em></code> 표시되는 유니코드 이스케이프 시퀀스를 포함할 수 있도록 허용합니다. <code class="type">json</code> 유형의 입력 함수에서는 데이터베이스 인코딩에 관계없이 유니코드 이스케이프가 허용되며 구문적 정확성(즉, 16진수 4자리 뒤에 <code class="literal">\u가</code> 오는지)만 검사합니다. 그러나 <code class="type">jsonb의</code> 입력 함수는 데이터베이스 인코딩으로 표현할 수 없는 문자에 대한 유니코드 이스케이프를 허용하지 않는 등 더 엄격하게 검사합니다. <code class="type">jsonb</code> 유형은 또한 <code class="literal">\u0000을</code> 거부하며( <span class="productname">PostgreSQL의</span> <code class="type">텍스트</code> 유형으로 표현할 수 없기 때문에), 유니코드 기본 다국어 평면 외부의 문자를 지정하기 위해 유니코드 대리 쌍을 사용하는 모든 것이 올바르다고 주장합니다.  유효한 유니코드 이스케이프는 저장할 수 있는 동등한 단일 문자로 변환되며, 여기에는 대리 쌍을 단일 문자로 접는 것도 포함됩니다. </p><div class="note"><h3 class="title">참고</h3><p>
  <a class="xref" href="functions-json.html" title="9.16. JSON Functions and Operators">섹션 9.16에</a> 설명된 많은 JSON 처리 함수는 유니코드 이스케이프를 일반 문자로 변환하므로 입력 유형이 <code class="type">jsonb가</code> 아닌 <code class="type">json인</code>경우에도 방금 설명한 것과 동일한 유형의 오류가 발생합니다. <code class="type">json</code> 입력 함수가 이러한 검사를 수행하지 않는다는 사실은 과거의 아티팩트로 간주될 수 있지만, 표현된 문자를 지원하지 않는 데이터베이스 인코딩에서 JSON 유니코드 이스케이프를 처리하지 않고 간단히 저장할 수 있습니다.  </p></div><p>
 <a class="xref" href="datatype-json.html#JSON-TYPE-MAPPING-TABLE" title="Table 8.23. JSON Primitive Types and Corresponding PostgreSQL Types">표 8.23에</a> 나와 있는 것처럼 텍스트 JSON 입력을 <code class="type">jsonb로</code> 변환할 때 <acronym class="acronym">RFC</acronym> 7159에서 설명하는 기본 유형은 기본 <span class="productname">PostgreSQL</span> 유형에 효과적으로 매핑됩니다. 따라서 유효한 <code class="type">jsonb</code> 데이터를 구성하는 항목에 대한 몇 가지 추가적인 제약이 있는데, 이는 기본 데이터 유형으로 표현할 수 있는 항목에 대한 제한에 해당하며, json 유형이나 초록의 JSON에는 적용되지 않습니다. 특히 <code class="type">jsonb는</code> <span class="productname">PostgreSQL</span> <code class="type">숫자</code> 데이터 유형의 범위를 벗어난 숫자는 거부하지만 <code class="type">json은</code> 거부하지 않습니다.  이러한 구현 정의 제한은 <acronym class="acronym">RFC</acronym> 7159에 의해 허용됩니다.  그러나 실제로는 다른 구현에서 이러한 문제가 발생할 가능성이 훨씬 더 높습니다. JSON의 <code class="type">숫자</code>기본 유형을 IEEE 754 배정밀도 부동 소수점으로 표현하는 것이 일반적이므로( <acronym class="acronym">RFC</acronym> 7159에서 명시적으로 예상하고 허용). 이러한 시스템과의 교환 형식으로 JSON을 사용할 때는 원래 <span class="productname">PostgreSQL에</span> 저장된 데이터에 비해 숫자 정밀도가 손실될 수 있는 위험을 고려해야 합니다. </p><p>
  반대로, 표에서 언급된 바와 같이, JSON 기본 유형의 입력 형식에는 해당 <span class="productname">PostgreSQL</span> 유형에 적용되지 않는 몇 가지 사소한 제한이 있습니다. </p><div class="table" id="JSON-TYPE-MAPPING-TABLE"><p class="title"><strong>표 8.23. JSON 기본 유형 및 대응하는 <span class="productname">PostgreSQL</span> 유형</strong></p><div class="table-contents"><table class="table" summary="JSON Primitive Types and Corresponding PostgreSQL Types" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>JSON 기본 유형</th><th><span class="productname">PostgreSQL</span> 유형</th><th>참고</th></tr></thead><tbody><tr><td><code class="type">문자열</code></td><td><code class="type">text</code></td><td>데이터베이스 인코딩에서 사용할 수 없는 문자를 나타내는 유니코드 이스케이프와 마찬가지로<code class="literal">\u0000은</code> 허용되지 않습니다.</td></tr><tr><td><code class="type">숫자</code></td><td><code class="type">숫자</code></td><td><code class="literal">NaN</code> 및 <code class="literal">무한대</code> 값은 허용되지 않습니다.</td></tr><tr><td><code class="type">boolean</code></td><td><code class="type">boolean</code></td><td>소문자 <code class="literal">참과</code> <code class="literal">거짓</code> 철자만 허용됩니다.</td></tr><tr><td><code class="type">null</code></td><td>(없음)</td><td>SQL <code class="literal">NULL은</code> 다른 개념입니다.</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect2" id="JSON-KEYS-ELEMENTS"><div class="titlepage"><div><div><h3 class="title">8.14.1. JSON 입력 및 출력 구문 <a href="#JSON-KEYS-ELEMENTS" class="id_link">#</a></h3></div></div></div><p>
   JSON 데이터 유형의 입력/출력 구문은 <acronym class="acronym">RFC</acronym> 7159에 명시된 대로입니다.  </p><p>
   다음은 모두 유효한 <code class="type">json</code> (또는 <code class="type">jsonb</code>) 표현식입니다:</p><pre class="programlisting">
-- 간단한 스칼라/기본값 -- 기본값은 숫자, 따옴표로 묶인 문자열, 참, 거짓 또는 null일 수 있음 SELECT '5'::json; -- 0개 이상의 요소 배열(요소의 유형이 같을 필요 없음) SELECT '[1, 2, "foo", null]'::json; -- 키와 값 쌍을 포함하는 개체 -- 개체 키는 항상 따옴표가 있는 문자열이어야 함에 유의함 SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json; -- 배열과 객체는 임의로 중첩될 수 있음 SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;</pre><p>
  </p><p>
   앞서 설명한 것처럼, JSON 값을 입력한 후 추가 처리 없이 출력할 때 <code class="type">json은</code> 입력된 것과 동일한 텍스트를 출력하는 반면, <code class="type">jsonb는</code> 공백과 같이 의미상 중요하지 않은 세부 사항은 보존하지 않습니다.  예를 들어 다음과 같은 차이점을 참고하세요:</p><pre class="programlisting">
SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json; json ------------------------------------------------- {"bar": "baz", "balance": 7.77, "active":false} (1 row) SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb; jsonb -------------------------------------------------- {"bar": "baz", "active": false, "balance": 7.77} (1 행)</pre><p>
   의미상으로는 중요하지 않은 한 가지 세부 사항은 <code class="type">jsonb에서</code> 숫자가 기본 <code class="type">숫자</code> 유형의 동작에 따라 인쇄된다는 것입니다.  실제로 이것은 예를 들어 <code class="literal">E</code> 표기법으로 입력된 숫자는 <code class="literal">E</code> 표기법 없이 인쇄된다는 것을 의미합니다:</p><pre class="programlisting">
SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb; json | jsonb -----------------------+------------------------- {"reading": 1.230e-5} | {"reading": 0.00001230} (1 행)</pre><p>
   그러나 이 예제에서 볼 수 있듯이 <code class="type">jsonb는</code> 동일성 검사와 같은 목적에서는 의미상 중요하지 않더라도 후행 소수점 0을 보존합니다.  </p><p>
    JSON 값을 구성하고 처리하는 데 사용할 수 있는 내장 함수 및 연산자 목록은 <a class="xref" href="functions-json.html" title="9.16. JSON Functions and Operators">섹션 9.16을</a> 참조하세요.  </p></div><div class="sect2" id="JSON-DOC-DESIGN"><div class="titlepage"><div><div><h3 class="title">8.14.2. JSON 문서 디자인 <a href="#JSON-DOC-DESIGN" class="id_link">#</a></h3></div></div></div><p>
   데이터를 JSON으로 표현하는 것은 기존의 관계형 데이터 모델보다 훨씬 더 유연할 수 있으며, 이는 요구사항이 유동적인 환경에서 유용합니다.  동일한 애플리케이션 내에서 두 가지 접근 방식이 공존하며 서로를 보완할 수 있습니다.  그러나 최대한의 유연성이 요구되는 애플리케이션의 경우에도 JSON 문서는 어느 정도 고정된 구조를 갖는 것이 좋습니다.  구조는 일반적으로 강제되지 않지만(일부 비즈니스 규칙을 선언적으로 적용하는 것은 가능하지만), 예측 가능한 구조가 있으면 테이블의 <span class="quote">'<span class="quote">문서</span>'</span> (데이텀) 집합을 유용하게 요약하는 쿼리를 작성하기가 더 쉬워집니다.  </p><p>
   JSON 데이터는 테이블에 저장할 때 다른 데이터 유형과 동일한 동시성 제어 고려 사항이 적용됩니다. 대용량 문서를 저장하는 것이 가능하지만, 모든 업데이트는 전체 행에 대해 행 수준 잠금을 획득한다는 점에 유의하세요. 업데이트 트랜잭션 간의 잠금 경합을 줄이려면 JSON 문서를 관리 가능한 크기로 제한하는 것을 고려하세요.  이상적으로, JSON 문서는 각각 원자 데이텀을 나타내야 하며, 비즈니스 규칙에 따라 독립적으로 수정할 수 있는 작은 데이텀으로 더 이상 세분화할 수 없습니다.  </p></div><div class="sect2" id="JSON-CONTAINMENT"><div class="titlepage"><div><div><h3 class="title">8.14.3. <code class="type">jsonb</code> 포함 및 존재 <a href="#JSON-CONTAINMENT" class="id_link">#</a>.</h3></div></div></div><a id="id-1.5.7.22.17.2" class="indexterm"></a><a id="id-1.5.7.22.17.3" class="indexterm"></a><p>
    테스트 <em class="firstterm">봉쇄는</em> <code class="type">jsonb의</code> 중요한 기능입니다. <code class="type">json</code> 유형에 대한 병렬 기능 세트는 없습니다.  포함 여부는 하나의 <code class="type">jsonb</code> 문서에 다른 문서가 포함되어 있는지 여부를 테스트합니다. 이 예제는 언급된 경우를 제외하고 참을 반환합니다:  </p><pre class="programlisting">
-- 단순 스칼라/원시값은 동일한 값만 포함합니다: SELECT '"foo"'::jsonb @&gt; '"foo"'::jsonb; -- 오른쪽 배열은 왼쪽 배열 내에 포함되어 있습니다: SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 3]'::jsonb; -- 배열 요소의 순서는 중요하지 않으므로 이것도 참입니다:
SELECT '[1, 2, 3]'::jsonb @&gt; '[3, 1]'::jsonb; -- 중복 배열 요소도 중요하지 않습니다: SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 2, 2]'::jsonb; -- 오른쪽에 한 쌍의 개체가 왼쪽의 개체 내에 -- 포함되어 있습니다: SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb": true}'::jsonb @&gt; '{"version": 9.4}'::jsonb; -- 유사한 배열이 중첩되어 있어도 오른쪽의 배열은 왼쪽의 배열에 포함된 것으로 <span class="emphasis"><strong>간주되지 않습니다</strong></span>: SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[1, 3]'::jsonb; -- false를 반환하지만 중첩 계층이 있으면 포함된다: SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[[1, 3]]'::jsonb; -- 마찬가지로, 여기에서도 포함이 보고되지 않는다: SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"bar": "baz"}'::jsonb; -- yields false -- 최상위 키와 빈 객체가 포함되어 있습니다: SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"foo": {}}'::jsonb;</pre><p>
   일반적인 원칙은 포함 객체에서 일부 일치하지 않는 배열 요소 또는 객체 키/값 쌍을 버린 후 구조와 데이터 내용이 포함 객체와 일치해야 한다는 것입니다. 그러나 포함 일치를 수행할 때 배열 요소의 순서는 중요하지 않으며 중복 배열 요소는 효과적으로 한 번만 고려된다는 점을 기억하세요.  </p><p>
   구조가 일치해야 한다는 일반적인 원칙에 대한 특별한 예외로 배열에 기본값이 포함될 수 있습니다:  </p><pre class="programlisting">
-- SELECT '["foo","bar"]'::jsonb @&gt; '"bar"'::jsonb; -- 이 배열은 원시 문자열 값을 포함합니다: SELECT '"bar"'::jsonb @&gt; '["bar"]'::jsonb; -- 이 예외는 상호적이지 않으며 여기서 포함되지 않는 것이 보고됩니다: SELECT '"bar"'::jsonb; -- 산출 결과 거짓값이 반환됩니다.</pre><p>
   <code class="type">jsonb에는</code> 포함을 주제로 한 변형인 <em class="firstterm">존재</em> 연산자도 있습니다. 이 연산자는 ( <code class="type">텍스트</code> 값으로 주어진) 문자열이 <code class="type">jsonb</code> 값의 최상위 수준에서 객체 키 또는 배열 요소로 나타나는지 여부를 테스트합니다. 이 예에서는 언급된 경우를 제외하고 참을 반환합니다:  </p><pre class="programlisting">
-- 문자열이 배열 요소로 존재함: SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar'; -- 문자열이 객체 키로 존재함: SELECT '{"foo": "bar"}'::jsonb ? 'foo'; -- 객체 값은 고려되지 않음: SELECT '{"foo": "bar"}'::jsonb ? 'bar'; -- yields false -- 포함과 마찬가지로 최상위 수준에서 존재가 일치해야 합니다: SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -- yields false -- 문자열이 원시 JSON 문자열과 일치하면 존재하는 것으로 간주됩니다: SELECT '"foo"'::jsonb ? 'foo';</pre><p>
    JSON 객체는 배열과 달리 내부적으로 검색에 최적화되어 있고 선형적으로 검색할 필요가 없기 때문에 키나 요소가 많을 때 포함 여부나 존재 여부를 테스트하는 데 배열보다 더 적합합니다.  </p><div class="tip"><h3 class="title">팁</h3><p>
    JSON 포함은 중첩되어 있으므로 적절한 쿼리는 하위 객체의 명시적 선택을 건너뛸 수 있습니다.  예를 들어 최상위 레벨에 개체가 포함된 <code class="structfield">문서</code> 열이 있고 대부분의 개체에 하위 개체의 배열을 포함하는 <code class="literal">태그</code> 필드가 포함되어 있다고 가정해 보겠습니다.  이 쿼리는 <code class="literal">태그</code> 배열 외부의 이러한 키는 무시하고 <code class="literal">"term":"paris</code> "와 <code class="literal">"term":"food</code> "를 모두 포함하는 하위 개체가 나타나는 항목을 찾습니다:</p><pre class="programlisting">
SELECT doc-&gt;'site_name' FROM websites WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';</pre><p>
    예를 들어 다음과 같이 동일한 작업을 수행할 수 있습니다,</p><pre class="programlisting">
SELECT doc-&gt;'site_name' FROM websites WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';</pre><p>
    하지만 이 접근 방식은 유연성이 떨어지고 효율성도 떨어지는 경우가 많습니다.   </p><p>
    반면에 JSON 존재 연산자는 중첩되지 않고 JSON 값의 최상위 수준에서 지정된 키 또는 배열 요소만 찾습니다.   </p></div><p>
    다양한 포함 및 존재 연산자와 다른 모든 JSON 연산자 및 함수는 <a class="xref" href="functions-json.html" title="9.16. JSON Functions and Operators">섹션 9.16에</a> 설명되어 있습니다.  </p></div><div class="sect2" id="JSON-INDEXING"><div class="titlepage"><div><div><h3 class="title">8.14.4. <code class="type">jsonb</code> 인덱싱 <a href="#JSON-INDEXING" class="id_link">#</a>.</h3></div></div></div><a id="id-1.5.7.22.18.2" class="indexterm"></a><p>
    GIN 인덱스는 많은 수의 <code class="type">jsonb</code> 문서(데이텀) 내에서 발생하는 키 또는 키/값 쌍을 효율적으로 검색하는 데 사용할 수 있습니다. 성능과 유연성 절충점을 제공하는 두 가지 GIN <span class="quote">"</span> 연산자 <span class="quote"><span class="quote">클래스</span></span> "가 제공됩니다.  </p><p>
   <code class="type">jsonb의</code> 기본 GIN 연산자 클래스는 키 존재 연산자 <code class="literal">?</code>, <code class="literal">?|</code>및 <code class="literal">?&amp;,</code> 포함 연산자 <code class="literal">@&gt;</code>, <code class="type">jsonpath</code> 일치 연산자 <code class="literal">@?</code> 및 <code class="literal">@@를</code> 사용한 쿼리를 지원합니다. (이러한 연산자가 구현하는 의미론에 대한 자세한 내용은 <a class="xref" href="functions-json.html#FUNCTIONS-JSONB-OP-TABLE" title="Table 9.46. Additional jsonb Operators">표 9.46을</a> 참조하십시오.) 이 연산자 클래스로 인덱스 생성의 예는 다음과 같습니다:</p><pre class="programlisting">
CREATE INDEX idxgin ON api USING GIN (jdoc);</pre><p>
    기본값이 아닌 GIN 연산자 클래스 <code class="literal">jsonb_path_ops는</code>키 존재 연산자를 지원하지 않지만 <code class="literal">@&gt;,</code>@ <code class="literal">?</code> 및 <code class="literal">@@은</code> 지원합니다. 이 연산자 클래스를 사용하여 인덱스를 생성하는 예는 다음과 같습니다:</p><pre class="programlisting">
CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);</pre><p>
  </p><p>
    문서화된 스키마 정의와 함께 타사 웹 서비스에서 검색한 JSON 문서를 저장하는 테이블의 예를 생각해 보세요.  일반적인 문서는 다음과 같습니다:</p><pre class="programlisting">
{ "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a", "name": "안젤라 바튼", "is_active": true, "회사": "마그나폰", "주소": "178 하워드 플레이스, 걸프, 워싱턴, 702", "등록된": "2009-11-07T08:53:22 +08:00", "위도": 19.793713, "경도": 86.513373, "태그": [ "enim", "aliquip", "qui" ] }</pre><p>
    이러한 문서는 <code class="structname">api라는</code> 이름의 테이블에 <code class="structfield">jdoc이라는</code> <code class="type">jsonb</code> 열에 저장됩니다. 이 열에 GIN 인덱스가 생성되면 다음과 같은 쿼리가 이 인덱스를 사용할 수 있습니다:</p><pre class="programlisting">
-- "company" 키가 "Magnafone" 값인 문서 찾기 SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';</pre><p>
    그러나 <code class="literal">?</code> 연산자는 색인 가능하지만 색인된 열 <code class="structfield">jdoc에</code> 직접 적용되지 않기 때문에 다음과 같은 쿼리에는 색인을 사용할 수 없습니다:</p><pre class="programlisting">
-- 키 "tags"에 키 또는 배열 요소 "qui"가 포함된 문서 찾기 SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';</pre><p>
    하지만 표현식 인덱스를 적절히 사용하면 위의 쿼리도 인덱스를 사용할 수 있습니다. <code class="literal">'tags</code> ' 키 내의 특정 항목에 대한 쿼리가 일반적인 경우 이와 같은 인덱스를 정의하는 것이 유용할 수 있습니다:</p><pre class="programlisting">
CREATE INDEX idxgintags ON api USING GIN ((jdoc -&gt; 'tags'));</pre><p>
    이제 <code class="literal">WHERE</code> 절에서 <code class="literal">jdoc -&gt; 'tags' ? 'qui'</code>는 인덱싱된 표현식 <code class="literal">jdoc -&gt; 'tags</code>'에 인덱서블 연산자 <code class="literal">?</code> 를 적용한 것으로 인식됩니다. (표현식 인덱스에 대한 자세한 내용은 <a class="xref" href="indexes-expressional.html" title="11.7. Indexes on Expressions">섹션 11.7에서</a> 확인할 수 있습니다.)  </p><p>
    쿼리에 대한 또 다른 접근 방식은 예를 들어 포함을 활용하는 것입니다:</p><pre class="programlisting">
-- 키 "tags"에 배열 요소 "qui"가 포함된 문서 찾기 SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';</pre><p>
   <code class="structfield">jdoc</code> 열의 간단한 GIN 인덱스가 이 쿼리를 지원할 수 있습니다.  그러나 이러한 인덱스는 <code class="structfield">jdoc</code> 열의 모든 키와 값의 복사본을 저장하는 반면, 이전 예제의 표현식 인덱스는 <code class="literal">tags</code> 키 아래에서 찾은 데이터만 저장한다는 점에 유의하세요.  단순 인덱스 접근 방식이 훨씬 더 유연하지만(모든 키에 대한 쿼리를 지원하기 때문에), 타깃 표현식 인덱스는 단순 인덱스보다 더 작고 검색 속도가 빠릅니다.  </p><p>
    GIN 인덱스는 <code class="literal">@?</code>및 <code class="literal">@@</code> 연산자도 지원하며, 이 연산자는 <code class="type">jsonpath</code> 일치를 수행합니다.  예는 다음과 같습니다.</p><pre class="programlisting">
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @? '$.tags[*] ? (@ == "qui")';</pre><p>
</p><pre class="programlisting">
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @@ '$.tags[*] == "qui"';</pre><p>
    이러한 연산자의 경우, GIN 인덱스는 <code class="type">jsonpath</code> 패턴에서 <code class="literal"><em class="replaceable"><code>accessors_chain</code></em>= <em class="replaceable"><code>constant</code></em></code> 형식의 절을 추출하고 이 절에 언급된 키와 값을 기반으로 인덱스 검색을 수행합니다.  접근자 체인에는 <code class="literal">.<em class="replaceable"><code>key</code></em></code>, <code class="literal">[*]</code>, <code class="literal">[<em class="replaceable"><code>index</code></em>]</code> 접근자가 포함될 수 있습니다. <code class="literal">jsonb_ops</code> 연산자 클래스는 <code class="literal">.*</code> 및 <code class="literal">.**</code> 접근자도 지원하지만, <code class="literal">jsonb_path_ops</code> 연산자 클래스는 지원하지 않습니다.  </p><p>
   <code class="literal">jsonb_path_ops</code> 연산자 클래스는 <code class="literal">@&gt;,</code>@ <code class="literal">?</code>및 <code class="literal">@@</code> 연산자를 사용하는 쿼리만 지원하지만, 기본 연산자 클래스인 <code class="literal">jsonb_ops에</code> 비해 성능 면에서 상당한 이점이 있습니다.  일반적으로 동일한 데이터에 대한 <code class="literal">jsonb_path_ops</code>인덱스는 <code class="literal">jsonb_ops</code>인덱스보다 훨씬 작으며, 특히 쿼리에 데이터에 자주 나타나는 키가 포함된 경우 검색의 특이성이 더 우수합니다.  따라서 일반적으로 기본 연산자 클래스보다 검색 작업이 더 잘 수행됩니다.  </p><p>
   <code class="literal">jsonb_ops와</code> <code class="literal">jsonb_path_ops</code> GIN 인덱스의 기술적 차이는 전자는 데이터의 각 키와 값에 대해 독립적인 인덱스 항목을 생성하는 반면, 후자는 데이터의 각 값에 대해서만 인덱스 항목을 생성한다는 것입니다. <a href="#ftn.id-1.5.7.22.18.9.3" class="footnote"><sup class="footnote" id="id-1.5.7.22.18.9.3">[7]</sup></a>기본적으로 각 <code class="literal">jsonb_path_ops</code> 인덱스 항목은 값과 해당 값으로 이어지는 키의 해시입니다(예: <code class="literal">{"foo": {"bar": "baz"}}를</code> 인덱싱하려면 <code class="literal">foo</code>, <code class="literal">bar</code>, <code class="literal">baz</code> 세 개를 모두 해시 값에 통합하는 단일 인덱스 항목이 생성됩니다.  따라서 이 구조를 찾는 포함 쿼리는 매우 구체적인 인덱스 검색이 되지만, <code class="literal">foo가</code>키로 나타나는지 여부를 알 수 있는 방법은 전혀 없습니다.  반면에, <code class="literal">jsonb_ops</code>인덱스는 <code class="literal">foo</code>, <code class="literal">bar</code>, <code class="literal">baz를</code> 나타내는 3개의 인덱스 항목을 별도로 생성한 다음, 포함 쿼리를 수행하기 위해 이 세 가지 항목을 모두 포함하는 행을 찾습니다.  GIN 인덱스는 이러한 AND 검색을 상당히 효율적으로 수행할 수 있지만, 특히 세 개의 인덱스 항목 중 하나라도 포함된 행이 매우 많은 경우에는 동등한 <code class="literal">jsonb_path_ops</code> 검색보다 덜 구체적이고 느립니다.  </p><p>
   <code class="literal">jsonb_path_ops</code> 접근 방식의 단점은 <code class="literal">{"a"</code> 같은 값을 포함하지 않는 JSON 구조에 대한 인덱스 항목이 생성되지 않는다는 것입니다: <code class="literal">{}}</code>.  이러한 구조가 포함된 문서에 대한 검색이 요청되면 전체 인덱스 스캔이 필요하므로 속도가 매우 느립니다. 따라서 이러한 검색을 자주 수행하는 애플리케이션에는 <code class="literal">jsonb_path_ops가</code> 적합하지 않습니다.  </p><p>
   <code class="type">jsonb는</code> <code class="literal">btree</code> 및 <code class="literal">해시</code>인덱스도 지원합니다.  이는 일반적으로 완전한 JSON 문서의 동일성을 확인하는 것이 중요한 경우에만 유용합니다. <code class="type">jsonb</code> 데이터의 <code class="literal">btree</code> 순서는 큰 관심사는 아니지만 완전성을 위해서는 중요합니다:</p><pre class="synopsis">
<em class="replaceable"><code>개체</code></em> &gt; <em class="replaceable"><code>배열</code></em> &gt; <em class="replaceable"><code>부울</code></em> &gt; <em class="replaceable"><code>숫자</code></em> &gt; <em class="replaceable"><code>문자열</code></em> &gt; <em class="replaceable"><code>Null</code></em>쌍이<em class="replaceable"><code>n개인 개체</code></em> &gt; n <em class="replaceable"><code>- 1쌍이 있는 개체</code></em>n개의<em class="replaceable"><code>요소가</code></em> 있는 배열 &gt; <em class="replaceable"><code>n - 1개의 요소가 있는 배열</code></em>순입니다.</pre><p>
      같은 수의 쌍을 가진 객체는 순서대로 비교됩니다:</p><pre class="synopsis">
<em class="replaceable"><code>키-1</code></em>, <em class="replaceable"><code>값-1</code></em>, <em class="replaceable"><code>키-2</code></em>...</pre><p>
      객체 키는 저장 순서대로 비교되며, 특히 짧은 키가 긴 키보다 먼저 저장되므로 다음과 같이 직관적이지 않을 수 있는 결과가 나올 수 있다는 점에 유의하세요:</p><pre class="programlisting">
{ "aa": 1, "c": 1} &gt; {"b": 1, "d": 1}</pre><p>
      마찬가지로 요소 수가 같은 배열은 순서대로 비교됩니다:</p><pre class="synopsis">
<em class="replaceable"><code>element-1</code></em>, <em class="replaceable"><code>element-2</code></em>...</pre><p>
      원시 JSON 값은 기본 <span class="productname">PostgreSQL</span> 데이터 유형과 동일한 비교 규칙을 사용하여 비교됩니다.  문자열은 기본 데이터베이스 콜레이션을 사용하여 비교됩니다.  </p></div><div class="sect2" id="JSONB-SUBSCRIPTING"><div class="titlepage"><div><div><h3 class="title">8.14.5. <code class="type">jsonb</code> 서브스크립션 <a href="#JSONB-SUBSCRIPTING" class="id_link">#</a>.</h3></div></div></div><p>
  <code class="type">jsonb</code> 데이터 유형은 요소를 추출하고 수정하기 위한 배열 스타일 첨자 표현식을 지원합니다. 중첩된 값은 <code class="literal">jsonb_set</code> 함수의 <code class="literal">경로</code>인수와 동일한 규칙에 따라 연결 아첨 표현식을 사용하여 나타낼 수 있습니다. <code class="type">jsonb</code>값이 배열인 경우 숫자 첨자는 0부터 시작하고 음수 정수는 배열의 마지막 요소부터 거꾸로 카운트합니다. 슬라이스 표현식은 지원되지 않습니다. 첨자 표현식의 결과는 항상 jsonb 데이터 유형입니다.  </p><p>
  <code class="command">UPDATE</code> 문은 <code class="literal">SET</code> 절에서 아첨을 사용하여 <code class="type">jsonb</code> 값을 수정할 수 있습니다. 아래 첨자 경로는 영향을 받는 모든 값에 대해 존재하는 한 순회할 수 있어야 합니다. 예를 들어, val <code class="literal">['a']['b']['c'</code> ] 경로는 모든 <code class="literal">val</code>, <code class="literal">val['a'</code>], <code class="literal">val['a']['b</code> ']가 객체인 경우 <code class="literal">c까지</code> 모두 순회할 수 있습니다. val <code class="literal">['a']</code> 또는 <code class="literal">val['a']['b']</code>가 정의되지 않은 경우 빈 객체로 생성되고 필요에 따라 채워집니다. 그러나 <code class="literal">val</code> 자체 또는 중간 값 중 하나가 문자열, 숫자 또는 <code class="literal">jsonb</code> <code class="literal">null과</code> 같은 객체가 아닌 것으로 정의되면 순회를 진행할 수 없으므로 오류가 발생하고 트랜잭션이 중단됩니다.  </p><p>
   첨자 구문의 예입니다:</p><pre class="programlisting">

-- 키로 객체 값 추출 SELECT ('{"a": 1}'::jsonb)['a']; -- 키 경로로 중첩된 객체 값 추출 SELECT ('{"a": {"b": {"c": 1}}}'::jsonb)['a']['b']['c']; -- 색인으로 배열 요소 추출 SELECT ('[1, "2", null]'::jsonb)[1]; -- 키로 개체 값 업데이트합니다. '1' 주위의 따옴표에 유의하세요. 할당된 값은 반드시 jsonb 타입이어야 합니다. UPDATE table_name SET jsonb_field['key'] = '1'; -- 레코드의 jsonb_field['a']['b']가 객체가 아닌 다른 것일 경우 오류가 발생합니다. 예를 들어 {"a": 1} 값은 키 'a'의 숫자 값을 --가집니다. UPDATE table_name SET jsonb_field['a']['b']['c'] = '1'; -- 아래 첨자와 함께 WHERE 절을 사용하여 레코드를 필터링합니다. 큰따옴표는 "value"도 유효한 jsonb 문자열이 되도록 합니다. SELECT * FROM table_name WHERE jsonb_field['key'] = '"value"';</pre><p>

   아래 첨자를 통한 <code class="type">jsonb</code> 할당은 <code class="literal">jsonb_set과</code> 몇 가지 에지 케이스를 다르게 처리합니다. 소스 <code class="type">jsonb</code>값이 <code class="literal">NULL인</code> 경우, 아래 첨자를 통한 할당은 아래 첨자 키가 암시하는 유형(객체 또는 배열)의 빈 JSON 값인 것처럼 진행됩니다:</p><pre class="programlisting">
-- jsonb_field가 NULL이었던 경우, 이제 {"a": 1} UPDATE table_name SET jsonb_field['a'] = '1'; -- jsonb_field가 NULL이었던 경우, 이제 [1] UPDATE table_name SET jsonb_field[0] = '1'이 됩니다;</pre><p>

   너무 적은 수의 요소가 포함된 배열에 인덱스가 지정되면 인덱스에 도달하여 값을 설정할 수 있을 때까지 <code class="literal">NULL</code> 요소가 추가됩니다.</p><pre class="programlisting">
-- jsonb_field가 []였던 곳은 이제 [null, null, 2]; -- jsonb_field가 [0]이었던 곳은 이제 [0, null, 2] UPDATE table_name SET jsonb_field[2] = '2';</pre><p>

  <code class="type">jsonb</code> 값은 해당 첨자가 암시하는 것처럼 마지막으로 순회할 기존 요소가 객체 또는 배열인 한 존재하지 않는 첨자 경로에 대한 할당을 허용합니다(경로의 마지막 첨자가 나타내는 요소는 순회되지 않으며 아무 요소나 될 수 있음). 중첩된 배열 및 객체 구조가 생성되며, 전자의 경우 할당된 값을 배치할 수 있을 때까지 아래 첨자 경로에 지정된 대로 <code class="literal">널 패딩됩니다</code>.</p><pre class="programlisting">
-- jsonb_field가 {}였던 경우 이제 {"a": [{"b": 1}]} UPDATE table_name SET jsonb_field['a'][0]['b'] = '1'; -- jsonb_field가 [] 이었던 경우, 이제 [null, {"a": 1}] UPDATE table_name SET jsonb_field[1]['a'] = '1'이 됩니다;</pre><p>

  </p></div><div class="sect2" id="DATATYPE-JSON-TRANSFORMS"><div class="titlepage"><div><div><h3 class="title">8.14.6. 트랜스폼 <a href="#DATATYPE-JSON-TRANSFORMS" class="id_link">#</a>.</h3></div></div></div><p>
   다른 절차적 언어에 대해 <code class="type">jsonb</code> 유형에 대한 변환을 구현하는 추가 확장을 사용할 수 있습니다.  </p><p>
   PL/Perl용 확장은 <code class="literal">jsonb_plperl</code> 및 <code class="literal">jsonb_plperlu라고</code> 합니다.  이 확장자를 사용하면 <code class="type">jsonb</code>값이 적절하게 Perl 배열, 해시 및 스칼라에 매핑됩니다.  </p><p>
   PL/Python용 확장자는 <code class="literal">jsonb_plpython3u입니다</code>. 이 확장자를 사용하면 <code class="type">jsonb</code> 값이 Python 사전, 목록 및 스칼라에 적절하게 매핑됩니다.  </p><p>
   이러한 확장 중 <code class="literal">jsonb_plperl은</code> <span class="quote">"<span class="quote">신뢰할</span></span> 수 있는" 확장으로 간주되므로 현재 데이터베이스에 대한 <code class="literal">CREATE</code> 권한이 있는 수퍼유저가 아닌 사용자도 설치할 수 있습니다.  나머지는 설치하려면 수퍼유저 권한이 필요합니다.  </p></div><div class="sect2" id="DATATYPE-JSONPATH"><div class="titlepage"><div><div><h3 class="title">8.14.7. jsonpath 유형 <a href="#DATATYPE-JSONPATH" class="id_link"> 번호</a></h3></div></div></div><a id="id-1.5.7.22.21.2" class="indexterm"></a><p>
  <code class="type">jsonpath</code> 타입은 JSON 데이터를 효율적으로 쿼리하기 위해 <span class="productname">PostgreSQL에서</span> SQL/JSON 경로 언어에 대한 지원을 구현합니다. 이 타입은 SQL/JSON 쿼리 함수로 추가 처리를 위해 경로 엔진이 JSON 데이터에서 검색할 항목을 지정하는 파싱된 SQL/JSON 경로 표현식의 이진 표현을 제공합니다.  </p><p>
   SQL/JSON 경로 술어와 연산자의 의미는 일반적으로 SQL을 따릅니다. 동시에 JSON 데이터로 작업하는 자연스러운 방법을 제공하기 위해 SQL/JSON 경로 구문은 몇 가지 JavaScript 규칙을 사용합니다:  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
     점(<code class="literal">.</code>)은 멤버 액세스에 사용됩니다.    </p></li><li class="listitem"><p>
     대괄호(<code class="literal">[]</code>)는 배열 액세스에 사용됩니다.    </p></li><li class="listitem"><p>
     SQL/JSON 배열은 1부터 시작하는 일반 SQL 배열과 달리 0 상대 배열입니다.    </p></li></ul></div><p>
   SQL/JSON 경로 표현식의 숫자 리터럴은 몇 가지 사소한 세부 사항에서 SQL 및 JSON과 다른 JavaScript 규칙을 따릅니다.  예를 들어 <code class="literal">,</code> SQL/JSON 경로에서는 <code class="literal">.1과</code> 1.  10진수가 아닌 정수 리터럴과 밑줄 구분 기호(예: <code class="literal">1_000_000</code>, <code class="literal">0x1EEE_FFFF</code>, <code class="literal">0o273</code>, <code class="literal">0b100101</code>)가 지원됩니다.  SQL/JSON 경로(그리고 자바스크립트에서는 SQL 고유 경로가 아님)에서는 기수 접두사 바로 뒤에 밑줄 구분 기호가 없어야 합니다.  </p><p>
   SQL/JSON 경로 표현식은 일반적으로 SQL 쿼리에서 SQL 문자 문자열 리터럴로 작성되므로 작은따옴표로 묶어야 하며 값 내에 원하는 작은따옴표는 이중으로 묶어야 합니다( <a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. String Constants">4.1.2.1 섹션</a> 참조). 일부 형태의 경로 표현식은 그 안에 문자열 리터럴을 포함해야 합니다.
   이러한 임베디드 문자열 리터럴은 JavaScript/ECMAScript 규칙을 따르며, 반드시 큰따옴표로 묶어야 하고, 그 안에 백슬래시 이스케이프를 사용하여 입력하기 어려운 문자를 나타낼 수 있습니다. 특히 임베디드 문자열 리터럴 안에 큰따옴표를 쓰는 방법은 <code class="literal">\"</code>, 백슬래시 자체를 쓰려면 <code class="literal">\\를</code> 써야 합니다.  기타 특수 백슬래시 시퀀스에는 JSON 문자열에서 인식되는 <code class="literal">\b</code>, <code class="literal">\f</code>, <code class="literal">\n</code>, <code class="literal">\r</code>, <code class="literal">\t</code>, <code class="literal">\v</code>(다양한 ASCII 제어 문자), 4자리 코드 포인트로 식별되는 유니코드 문자의 <code class="literal"><em class="replaceable"><code>\uNNNN</code></em></code> 등이 있습니다.  또한 백슬래시 구문에는 두 자리 16진수로만 작성된 문자 코드인 <code class="literal"><em class="replaceable"><code>\xNN과</code></em></code> 1~6자리 16진수로 작성된 문자 코드인 <code class="literal">\u{N<em class="replaceable"><code>...</code></em>}</code> 등 JSON에서 허용되지 않는 두 가지 경우가 포함됩니다.  </p><p>
   경로 표현식은 다음 중 어느 것이든 될 수 있는 경로 요소의 시퀀스로 구성됩니다:   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      JSON 기본 유형의 경로 리터럴: 유니코드 텍스트, 숫자, 참, 거짓 또는 null.     </p></li><li class="listitem"><p>
     <a class="xref" href="datatype-json.html#TYPE-JSONPATH-VARIABLES" title="Table 8.24. jsonpath Variables">표 8.24에</a> 나열된 경로 변수.     </p></li><li class="listitem"><p>
     <a class="xref" href="datatype-json.html#TYPE-JSONPATH-ACCESSORS" title="Table 8.25. jsonpath Accessors">표 8.25에</a> 나열된 접근자 연산자.     </p></li><li class="listitem"><p>
     <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.16.2.2. SQL/JSON Path Operators and Methods">섹션 9.16.2.2에</a> 나열된 <code class="type">jsonpath</code> 연산자 및 메서드.     </p></li><li class="listitem"><p>
      필터 표현식을 제공하거나 경로 평가 순서를 정의하는 데 사용할 수 있는 괄호.     </p></li></ul></div><p>
  </p><p>
   SQL/JSON 쿼리 함수와 함께 <code class="type">jsonpath</code> 표현식을 사용하는 방법에 대한 자세한 내용은 <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH" title="9.16.2. The SQL/JSON Path Language">섹션 9.16.2를</a> 참조하십시오.  </p><div class="table" id="TYPE-JSONPATH-VARIABLES"><p class="title"><strong>표 8.24. <code class="type">jsonpath</code> 변수</strong></p><div class="table-contents"><table class="table" summary="jsonpath Variables" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>변수</th><th>설명</th></tr></thead><tbody><tr><td><code class="literal">$</code></td><td>쿼리 중인 JSON 값( <em class="firstterm">컨텍스트 항목</em>)을 나타내는 변수입니다.      </td></tr><tr><td><code class="literal">$varname</code></td><td>
        명명된 변수입니다. 이 값은 여러 JSON 처리 함수의 매개변수 <em class="parameter"><code>vars로</code></em> 설정할 수 있습니다(자세한 내용은 <a class="xref" href="functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE" title="Table 9.49. JSON Processing Functions">표 9.49</a> 참조).      </td></tr><tr><td><code class="literal">@</code></td><td>필터 표현식에서 경로 평가 결과를 나타내는 변수입니다.      </td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="TYPE-JSONPATH-ACCESSORS"><p class="title"><strong>표 8.25. <code class="type">jsonpath</code> 접근자</strong></p><div class="table-contents"><table class="table" summary="jsonpath Accessors" border="1"><colgroup><col class="col1" /><col class="col2" /></colgroup><thead><tr><th>접근자 연산자</th><th>설명</th></tr></thead><tbody><tr><td>
       <p>
       <code class="literal">.<em class="replaceable"><code>key</code></em></code>   </p>
       <p>
       <code class="literal">."<em class="replaceable"><code>$varname</code></em></code>"       </p>
      </td><td>
       <p>
        지정된 키를 가진 객체 멤버를 반환하는 멤버 접근자입니다. 키 이름이 <code class="literal">$로</code> 시작하는 명명된 변수와 일치하거나 식별자에 대한 JavaScript 규칙을 충족하지 않는 경우 문자열 리터럴로 만들기 위해 큰따옴표로 묶어야 합니다.       </p>
      </td></tr><tr><td>
       <p>
       <code class="literal">.</code>*  </p>
      </td><td>
       <p>
        현재 객체의 최상위 레벨에 있는 모든 멤버의 값을 반환하는 와일드카드 멤버 접근자입니다.       </p>
      </td></tr><tr><td>
       <p>
       <code class="literal">.**</code>  </p>
      </td><td>
       <p>
        현재 개체의 JSON 계층 구조의 모든 수준을 처리하고 중첩 수준에 관계없이 모든 멤버 값을 반환하는 재귀적 와일드카드 멤버 접근자입니다. 이것은 SQL/JSON 표준의 <span class="productname">PostgreSQL</span> 확장입니다.       </p>
      </td></tr><tr><td>
       <p>
       <code class="literal">.<em class="replaceable"><code>**{level}</code></em></code>      </p>
       <p>
       <code class="literal">. <em class="replaceable"><code>**{시작_레벨~끝_레벨}</code></em></code>      </p>
      </td><td>
       <p>
       <code class="literal">.**와</code> 비슷하지만 JSON 계층 구조의 지정된 수준만 선택합니다. 중첩 레벨은 정수로 지정됩니다. 레벨 0은 현재 객체에 해당합니다. 가장 낮은 중첩 수준에 액세스하려면 <code class="literal">마지막</code> 키워드를 사용할 수 있습니다. 이것은 SQL/JSON 표준의 <span class="productname">PostgreSQL</span> 확장입니다.       </p>
      </td></tr><tr><td>
       <p>
       <code class="literal">[아래<em class="replaceable"><code>첨자</code></em>, ...]</code>   </p>
      </td><td>
       <p>
        배열 엘리먼트 접근자 <code class="literal"><em class="replaceable"><code>구독자는</code></em></code> <code class="literal"><em class="replaceable"><code>인덱스</code></em></code>또는 <code class="literal"><em class="replaceable"><code>start_index에서</code></em> <em class="replaceable"><code>end_index까지</code></em></code> 두 가지 형태로 지정할 수 있습니다. 첫 번째 형태는 인덱스별로 단일 배열 엘리먼트를 반환합니다. 두 번째 형식은 제공된 <em class="replaceable"><code>start_index</code></em> 및 <em class="replaceable"><code>end_index에</code></em> 해당하는 요소를 포함하여 인덱스 범위별로 배열 슬라이스를 반환합니다.       </p>
       <p>
        지정된 <em class="replaceable"><code>인덱스는</code></em> 정수일 수도 있고 단일 숫자 값을 반환하는 표현식일 수도 있으며, 이 경우 자동으로 정수로 캐스팅됩니다. 인덱스 0은 첫 번째 배열 요소에 해당합니다. <code class="literal">마지막</code> 키워드를 사용하여 마지막 배열 요소를 나타낼 수도 있으며, 이는 길이를 알 수 없는 배열을 처리할 때 유용합니다.       </p>
      </td></tr><tr><td>
       <p>
       <code class="literal">[*</code>]   </p>
      </td><td>
       <p>
        모든 배열 요소를 반환하는 와일드카드 배열 요소 접근자입니다.       </p>
      </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.7.22.18.9.3" class="footnote"><p><a href="#id-1.5.7.22.18.9.3" class="para"><sup class="para">[7] </sup></a>이 목적을 위해 <span class="quote">"<span class="quote">값</span>"이라는</span> 용어에는 배열 요소가 포함되지만, JSON 용어에서는 배열 요소를 객체 내의 값과 구별되는 것으로 간주하는 경우가 있습니다.     </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-xml.html" title="8.13. XML Type">이전</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html" title="Chapter 8. Data Types">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="arrays.html" title="8.15. Arrays">다음</a></td></tr><tr><td width="40%" align="left" valign="top">8.13. <acronym class="acronym">XML</acronym> 유형 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="40%" align="right" valign="top"> 8.15. 배열</td></tr></table></div></body></html>