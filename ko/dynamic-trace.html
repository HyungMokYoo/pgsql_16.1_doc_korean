<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>28.5. 동적 추적</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="progress-reporting.html" title="28.4. Progress Reporting" /><link rel="next" href="diskusage.html" title="Chapter 29. Monitoring Disk Usage" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">28.5. 동적 추적</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="progress-reporting.html" title="28.4. Progress Reporting">이전</a> </td><td width="10%" align="left"><a accesskey="u" href="monitoring.html" title="Chapter 28. Monitoring Database Activity">Up</a></td><th width="60%" align="center">28장. 데이터베이스 활동 모니터링</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="10%" align="right"> <a accesskey="n" href="diskusage.html" title="Chapter 29. Monitoring Disk Usage">다음</a></td></tr></table><hr /></div><div class="sect1" id="DYNAMIC-TRACE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">28.5. 동적 추적 <a href="#DYNAMIC-TRACE" class="id_link">#</a></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="dynamic-trace.html#COMPILING-FOR-TRACE">28.5.1. 다이내믹 트레이싱을 위한 컴파일</a></span></dt><dt><span class="sect2"><a href="dynamic-trace.html#TRACE-POINTS">28.5.2. 내장 프로브</a></span></dt><dt><span class="sect2"><a href="dynamic-trace.html#USING-TRACE-POINTS">28.5.3. 프로브 사용하기</a></span></dt><dt><span class="sect2"><a href="dynamic-trace.html#DEFINING-TRACE-POINTS">28.5.4. 새 프로브 정의하기</a></span></dt></dl></div><a id="id-1.6.15.10.2" class="indexterm"></a><p>
  <span class="productname">PostgreSQL은</span> 데이터베이스 서버의 동적 추적을 지원하는 기능을 제공합니다. 이를 통해 코드의 특정 지점에서 외부 유틸리티를 호출하여 실행을 추적할 수 있습니다.  </p><p>
   여러 프로브 또는 추적 지점이 이미 소스 코드에 삽입되어 있습니다. 이러한 프로브는 데이터베이스 개발자와 관리자가 사용하기 위한 것입니다. 기본적으로 프로브는 <span class="productname">PostgreSQL로</span> 컴파일되지 않으며, 사용자가 프로브를 사용하려면 구성 스크립트에 명시적으로 알려주어야 합니다.  </p><p>
   현재 이 글을 쓰는 시점에 Solaris, macOS, FreeBSD, NetBSD 및 Oracle Linux에서 사용할 수 있는 <a class="ulink" href="https://en.wikipedia.org/wiki/DTrace" target="_top">DTrace</a>유틸리티가 지원되고 있습니다.  Linux용 <a class="ulink" href="https://sourceware.org/systemtap/" target="_top">SystemTap</a> 프로젝트는 DTrace와 동등한 기능을 제공하며 이 프로젝트도 사용할 수 있습니다.  다른 동적 추적 유틸리티를 지원하는 것은 이론적으로 <code class="filename">src/include/utils/probes.h에서</code> 매크로에 대한 정의를 변경하면 가능합니다.  </p><div class="sect2" id="COMPILING-FOR-TRACE"><div class="titlepage"><div><div><h3 class="title">28.5.1. 동적 추적을 위해 컴파일하기 <a href="#COMPILING-FOR-TRACE" class="id_link">#</a>.</h3></div></div></div><p>
   기본적으로 프로브는 사용할 수 없으므로 구성 스크립트에 명시적으로 프로브를 사용할 수 있게 하려면 <span class="productname">PostgreSQL에서</span> 프로브를 사용하도록 설정해야 합니다. DTrace 지원을 포함하려면 <code class="option">--enable-dtrace를</code> 지정하여 구성합니다.  자세한 내용은 <a class="xref" href="install-make.html#CONFIGURE-OPTIONS-DEVEL" title="17.3.3.6. Developer Options">섹션 17.3.3.6을</a> 참조하세요.  </p></div><div class="sect2" id="TRACE-POINTS"><div class="titlepage"><div><div><h3 class="title">28.5.2. 기본 제공 프로브 <a href="#TRACE-POINTS" class="id_link">#</a></h3></div></div></div><p>
  <a class="xref" href="dynamic-trace.html#DTRACE-PROBE-POINT-TABLE" title="Table 28.48. Built-in DTrace Probes">표 28.48에</a> 표시된 것처럼 소스 코드에 여러 표준 프로브가 제공되며, <a class="xref" href="dynamic-trace.html#TYPEDEFS-TABLE" title="Table 28.49. Defined Types Used in Probe Parameters">표 28.49에는</a>프로브에 사용된 유형이 나와 있습니다.  더 많은 프로브를 추가하여 <span class="productname">PostgreSQL의</span> 관찰 가능성을 향상시킬 수 있습니다.  </p><div class="table" id="DTRACE-PROBE-POINT-TABLE"><p class="title"><strong>표 28.48. 기본 제공 DTrace 프로브</strong></p><div class="table-contents"><table class="table" summary="Built-in DTrace Probes" border="1"><colgroup><col class="col1" /><col class="col2" /><col class="col3" /></colgroup><thead><tr><th>이름</th><th>매개 변수</th><th>설명</th></tr></thead><tbody><tr><td><code class="literal">트랜잭션 시작</code></td><td><code class="literal">(로컬 트랜잭션 ID)</code></td><td>새 트랜잭션이 시작될 때 실행되는 프로브입니다. arg0은 트랜잭션 ID입니다.</td></tr><tr><td><code class="literal">트랜잭션 커밋</code></td><td><code class="literal">(로컬 트랜잭션 ID)</code></td><td>트랜잭션이 성공적으로 완료되면 실행되는 프로브. 인수 0은 트랜잭션 ID입니다.</td></tr><tr><td><code class="literal">트랜잭션-어보트</code></td><td><code class="literal">(로컬 트랜잭션 ID)</code></td><td>트랜잭션이 실패로 완료될 때 발생하는 프로브. 인수 0은 트랜잭션 ID입니다.</td></tr><tr><td><code class="literal">query-start</code></td><td><code class="literal">(const char *)</code></td><td>쿼리 처리가 시작될 때 발생하는 프로브. arg0은 쿼리 문자열입니다.</td></tr><tr><td><code class="literal">query-done</code></td><td><code class="literal">(const char *)</code></td><td>쿼리 처리가 완료될 때 발생하는 프로브.</td></tr><tr><td><code class="literal">쿼리-파싱-시작</code></td><td><code class="literal">(const char *)</code></td><td>쿼리 구문 분석이 시작될 때 발생하는 프로브. arg0은 쿼리 문자열입니다.</td></tr><tr><td><code class="literal">쿼리-파싱-완료</code></td><td><code class="literal">(const char *)</code></td><td>쿼리 구문 분석이 완료되면 발생하는 프로브입니다. arg0은 쿼리 문자열입니다.</td></tr><tr><td><code class="literal">쿼리 재작성 시작</code></td><td><code class="literal">(const char *)</code></td><td>쿼리 재작성이 시작될 때 실행되는 프로브. arg0은 쿼리 문자열입니다.</td></tr><tr><td><code class="literal">query-rewrite-done</code></td><td><code class="literal">(const char *)</code></td><td>쿼리 재작성이 완료되면 발생하는 프로브입니다. 인자 0은 쿼리 문자열입니다.</td></tr><tr><td><code class="literal">쿼리 계획 시작</code></td><td><code class="literal">()</code></td><td>쿼리 계획이 시작될 때 실행되는 프로브입니다.</td></tr><tr><td><code class="literal">쿼리-계획-완료</code></td><td><code class="literal">()</code></td><td>쿼리 계획이 완료되면 실행되는 프로브.</td></tr><tr><td><code class="literal">쿼리 실행 시작</code></td><td><code class="literal">()</code></td><td>쿼리 실행이 시작될 때 실행되는 프로브.</td></tr><tr><td><code class="literal">쿼리 실행 완료</code></td><td><code class="literal">()</code></td><td>쿼리 실행이 완료되면 실행되는 프로브입니다.</td></tr><tr><td><code class="literal">statement-status</code></td><td><code class="literal">(const char *)</code></td><td>서버 프로세스가 <code class="structname">pg_stat_activity</code><code class="structfield">.status를</code> 업데이트할 때마다 실행되는 프로브. arg0은 새 상태 문자열입니다.</td></tr><tr><td><code class="literal">checkpoint-start</code></td><td><code class="literal">(int)</code></td><td>체크포인트가 시작될 때 실행되는 프로브. arg0에는 종료, 즉시 또는 강제와 같은 다양한 체크포인트 유형을 구분하는 데 사용되는 비트 단위 플래그가 있습니다.</td></tr><tr><td><code class="literal">체크포인트 완료</code></td><td><code class="literal">(int, int, int, int, int)</code></td><td>체크포인트가 완료되면 실행되는 프로브. (다음에 나열된 프로브는 체크포인트 처리 중에 순서대로 실행됩니다.) arg0은 기록된 버퍼의 수입니다. arg1은 총 버퍼의 수입니다. arg2, arg3 및 arg4에는 각각 추가, 제거 및 재활용된 WAL 파일의 수가 포함됩니다.</td></tr><tr><td><code class="literal">clog-checkpoint-start</code></td><td><code class="literal">(bool)</code></td><td>체크포인트의 CLOG 부분이 시작될 때 실행되는 프로브입니다. 일반 체크포인트의 경우 arg0은 참이고, 종료 체크포인트의 경우 거짓입니다.</td></tr><tr><td><code class="literal">clog-checkpoint-done</code></td><td><code class="literal">(bool)</code></td><td>체크포인트의 CLOG 부분이 완료되면 실행되는 프로브입니다. arg0은 <code class="literal">clog-checkpoint-start와</code> 동일한 의미를 갖습니다.</td></tr><tr><td><code class="literal">서브트랜스 체크포인트 시작</code></td><td><code class="literal">(bool)</code></td><td>체크포인트의 서브트랜스 부분이 시작될 때 실행되는 프로브입니다. 일반 체크포인트의 경우 arg0은 참이고 종료 체크포인트의 경우 거짓입니다.</td></tr><tr><td><code class="literal">서브트랜스-체크포인트-완료</code></td><td><code class="literal">(bool)</code></td><td>체크포인트의 서브트랜스 부분이 완료되면 실행되는 프로브입니다. arg0은 <code class="literal">서브트랜스 체크포인트 시작과</code> 동일한 의미를 갖습니다.</td></tr><tr><td><code class="literal">multixact-checkpoint-start</code></td><td><code class="literal">(bool)</code></td><td>체크포인트의 멀티액트 부분이 시작될 때 실행되는 프로브입니다. 일반 체크포인트의 경우 arg0은 참이고 종료 체크포인트의 경우 거짓입니다.</td></tr><tr><td><code class="literal">multixact-checkpoint-done</code></td><td><code class="literal">(bool)</code></td><td>체크포인트의 멀티액트 부분이 완료되면 실행되는 프로브. arg0은 <code class="literal">멀티액트-체크포인트 시작과</code> 동일한 의미를 갖습니다.</td></tr><tr><td><code class="literal">버퍼-체크포인트-시작</code></td><td><code class="literal">(int)</code></td><td>체크포인트의 버퍼 쓰기 부분이 시작될 때 발생하는 프로브입니다. arg0에는 종료, 즉시 또는 강제와 같은 다양한 체크포인트 유형을 구분하는 데 사용되는 비트 단위 플래그가 있습니다.</td></tr><tr><td><code class="literal">buffer-sync-start</code></td><td><code class="literal">(int, int)</code></td><td>체크포인트 중에 더티 버퍼를 쓰기 시작할 때(어떤 버퍼를 써야 하는지 식별한 후) 실행되는 프로브입니다. arg0은 총 버퍼 수입니다. arg1은 현재 더티 상태이고 써야 하는 버퍼 수입니다.</td></tr><tr><td><code class="literal">buffer-sync-written</code></td><td><code class="literal">(int)</code></td><td>체크포인트 중에 각 버퍼가 쓰여질 때마다 발생하는 프로브입니다. arg0은 버퍼의 ID 번호입니다.</td></tr><tr><td><code class="literal">buffer-sync-done</code></td><td><code class="literal">(int, int, int)</code></td><td>모든 더티 버퍼가 쓰여졌을 때 실행되는 프로브. arg0은 총 버퍼 수. arg1은 체크포인트 프로세스가 실제로 쓴 버퍼 수. arg2는 쓰여질 것으로 예상했던 수( <code class="literal">buffer-sync-start의</code> arg1)이며, 차이는 체크포인트 중에 버퍼를 플러시하는 다른 프로세스를 반영합니다.</td></tr><tr><td><code class="literal">버퍼-체크포인트-동기화-시작</code></td><td><code class="literal">()</code></td><td>더티 버퍼가 커널에 쓰여진 후, 그리고 fsync 요청을 시작하기 전에 실행되는 프로브.</td></tr><tr><td><code class="literal">버퍼-체크포인트-완료</code></td><td><code class="literal">()</code></td><td>디스크에 대한 버퍼의 동기화가 완료되면 발생하는 프로브.</td></tr><tr><td><code class="literal">2단계 체크포인트 시작</code></td><td><code class="literal">()</code></td><td>체크포인트의 2단계 부분이 시작될 때 실행되는 프로브.</td></tr><tr><td><code class="literal">2단계 체크포인트 완료</code></td><td><code class="literal">()</code></td><td>체크포인트의 2상 부분이 완료되면 실행되는 프로브.</td></tr><tr><td><code class="literal">buffer-extend-start</code></td><td><code class="literal">(포크 번호, 블록 번호, Oid, Oid, Oid, int, 부호 없는 int)</code></td><td>관계 확장이 시작될 때 실행되는 프로브. arg0에는 확장할 포크가 포함됩니다. arg1, arg2 및 arg3에는 관계를 식별하는 테이블스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg4는 로컬 버퍼의 경우 임시 관계를 생성한 백엔드의 ID 또는 공유 버퍼의 경우 <code class="symbol">InvalidBackendId</code> (-1)입니다. arg5는 호출자가 확장하고자 하는 블록 수입니다.</td></tr><tr><td><code class="literal">buffer-extend-done</code></td><td><code class="literal">(포크 번호, 블록 번호, Oid, Oid, Oid, int, 부호 없는 int, 블록 번호)</code></td><td>관계 확장이 완료되면 실행되는 프로브입니다. arg0에는 확장할 포크가 포함됩니다. arg1, arg2 및 arg3에는 관계를 식별하는 테이블스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg4는 로컬 버퍼의 경우 임시 관계를 생성한 백엔드의 ID, 공유 버퍼의 경우 <code class="symbol">InvalidBackendId</code> (-1)입니다. arg5는 관계가 확장된 블록의 수로, 자원 제약으로 인해 <code class="literal">buffer-extend-start의</code> 수보다 작을 수 있습니다. arg6에는 처음 새 블록의 BlockNumber가 포함됩니다.</td></tr><tr><td><code class="literal">buffer-read-start</code></td><td><code class="literal">(포크 번호, 블록 번호, Oid, Oid, Oid, int)</code></td><td>버퍼 읽기가 시작될 때 실행되는 프로브입니다. arg0과 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼의 경우 임시 관계를 생성한 백엔드의 ID 또는 공유 버퍼의 경우 <code class="symbol">InvalidBackendId</code> (-1)를 포함합니다.      </td></tr><tr><td><code class="literal">buffer-read-done</code></td><td><code class="literal">(포크 번호, 블록 번호, Oid, Oid, Oid, int, bool)</code></td><td>버퍼 읽기가 완료되면 실행되는 프로브입니다. arg0과 arg1에는 페이지의 포크 번호와 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼의 경우 임시 관계를 생성한 백엔드의 ID, 공유 버퍼의 경우 <code class="symbol">InvalidBackendId</code> (-1), arg6은 버퍼가 풀에서 발견되면 true, 그렇지 않으면 false가 됩니다.</td></tr><tr><td><code class="literal">buffer-flush-start</code></td><td><code class="literal">(포크 번호, 블록 번호, Oid, Oid, Oid)</code></td><td>공유 버퍼에 대한 쓰기 요청을 실행하기 전에 실행되는 프로브. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 테이블 스페이스, 데이터베이스 및 관계를 식별하는 관계 OID가 포함됩니다.</td></tr><tr><td><code class="literal">buffer-flush-done</code></td><td><code class="literal">(포크 번호, 블록 번호, Oid, Oid, Oid)</code></td><td>쓰기 요청이 완료되면 실행되는 프로브입니다.  (이것은 데이터를 커널로 전달하는 시간만 반영하며, 일반적으로 아직 디스크에 실제로 쓰여지지 않았습니다.) 인자는 <code class="literal">buffer-flush-start와</code> 동일합니다.</td></tr><tr><td><code class="literal">wal-buffer-write-dirty-start</code></td><td><code class="literal">()</code></td><td>서버 프로세스가 더 이상 사용 가능한 WAL 버퍼 공간이 없어서 더티 WAL 버퍼를 쓰기 시작할 때 실행되는 프로브. (이런 일이 자주 발생하면 <a class="xref" href="runtime-config-wal.html#GUC-WAL-BUFFERS">wal_buffers가</a> 너무 작다는 뜻입니다.)</td></tr><tr><td><code class="literal">wal-buffer-write-dirty-done</code></td><td><code class="literal">()</code></td><td>더티 WAL 버퍼 쓰기가 완료되면 실행되는 프로브.</td></tr><tr><td><code class="literal">wal-insert</code></td><td><code class="literal">(서명되지 않은 문자, 서명되지 않은 문자)</code></td><td>WAL 레코드가 삽입될 때 실행되는 프로브. arg0은 레코드의 리소스 관리자(rmid)입니다. arg1에는 정보 플래그가 포함됩니다.</td></tr><tr><td><code class="literal">wal-switch</code></td><td><code class="literal">()</code></td><td>WAL 세그먼트 전환이 요청될 때 실행되는 프로브.</td></tr><tr><td><code class="literal">smgr-md-read-start</code></td><td><code class="literal">(포크번호, 블록번호, Oid, Oid, Oid, int)</code></td><td>관계에서 블록 읽기를 시작할 때 실행되는 프로브입니다. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼의 경우 임시 관계를 생성한 백엔드의 ID 또는 공유 버퍼의 경우 <code class="symbol">InvalidBackendId</code> (-1)입니다.</td></tr><tr><td><code class="literal">smgr-md-read-done</code></td><td><code class="literal">(포크 번호, 블록 번호, Oid, Oid, Oid, int, int, int)</code></td><td>블록 읽기가 완료되면 실행되는 프로브입니다. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼의 경우 임시 관계를 생성한 백엔드의 ID, 공유 버퍼의 경우 <code class="symbol">InvalidBackendId</code> (-1), arg6은 실제로 읽은 바이트 수, arg7은 요청된 수(다르면 문제를 나타냅니다.)입니다.</td></tr><tr><td><code class="literal">smgr-md-write-start</code></td><td><code class="literal">(포크 번호, 블록 번호, Oid, Oid, Oid, int)</code></td><td>관계에 블록 쓰기를 시작할 때 실행되는 프로브입니다. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼의 경우 임시 관계를 생성한 백엔드 ID, 공유 버퍼의 경우 <code class="symbol">InvalidBackendId</code> (-1)입니다.</td></tr><tr><td><code class="literal">smgr-md-write-done</code></td><td><code class="literal">(포크 번호, 블록 번호, Oid, Oid, Oid, int, int, int)</code></td><td>블록 쓰기가 완료되면 실행되는 프로브입니다. arg0 및 arg1에는 페이지의 포크 및 블록 번호가 포함됩니다. arg2, arg3 및 arg4에는 관계를 식별하는 테이블 스페이스, 데이터베이스 및 관계 OID가 포함됩니다. arg5는 로컬 버퍼의 경우 임시 관계를 생성한 백엔드의 ID, 공유 버퍼의 경우 <code class="symbol">InvalidBackendId</code> (-1)입니다. arg6은 실제로 쓰여진 바이트 수, arg7은 요청된 수(다르면 문제를 나타냅니다.)입니다.</td></tr><tr><td><code class="literal">sort-start</code></td><td><code class="literal">(int, bool, int, int, int, bool, int)</code></td><td>정렬 작업이 시작될 때 실행되는 프로브입니다. arg0은 힙, 인덱스 또는 데이텀 정렬을 나타냅니다. arg1은 고유 값 적용 시 참입니다. arg2는 키 열 수입니다. arg3은 허용되는 작업 메모리 킬로바이트 수입니다. arg4는 정렬 결과에 대한 임의 액세스가 필요한 경우 참입니다. arg5는 <code class="literal">0이면</code> 직렬, <code class="literal">1이면</code> 병렬 워커, <code class="literal">2이면</code> 병렬 리더를 나타냅니다.</td></tr><tr><td><code class="literal">sort-done</code></td><td><code class="literal">(부울, 긴)</code></td><td>정렬이 완료되면 실행되는 프로브. arg0은 외부 정렬의 경우 참, 내부 정렬의 경우 거짓입니다. arg1은 외부 정렬에 사용된 디스크 블록 수 또는 내부 정렬에 사용된 메모리 킬로바이트입니다.</td></tr><tr><td><code class="literal">lwlock-acquire</code></td><td><code class="literal">(문자 *, LWLockMode)</code></td><td>LWLock이 획득되었을 때 발생하는 프로브. arg0은 LWLock의 트랜치입니다. arg1은 요청된 잠금 모드(독점 또는 공유 중 하나)입니다.</td></tr><tr><td><code class="literal">lwlock-release</code></td><td><code class="literal">(문자 *)</code></td><td>LWLock이 해제되었을 때 발생하는 프로브입니다(단, 해제된 웨이터는 아직 깨어나지 않았음에 유의). arg0은 LWLock의 트랜치입니다.</td></tr><tr><td><code class="literal">lwlock-wait-start</code></td><td><code class="literal">(문자 *, LWLockMode)</code></td><td>LWLock을 즉시 사용할 수 없고 서버 프로세스가 잠금을 사용할 수 있게 될 때까지 대기하기 시작했을 때 발생하는 프로브. arg0은 LWLock의 트랜치입니다. arg1은 요청된 잠금 모드(독점 또는 공유 중 하나)입니다.</td></tr><tr><td><code class="literal">lwlock-wait-done</code></td><td><code class="literal">(문자 *, LWLockMode)</code></td><td>서버 프로세스가 LWLock 대기에서 해제되었을 때(실제로는 아직 잠금이 없음) 발생하는 프로브입니다. arg0은 LWLock의 트랜치입니다. arg1은 요청된 잠금 모드(독점 또는 공유)입니다.</td></tr><tr><td><code class="literal">lwlock-condacquire</code></td><td><code class="literal">(문자 *, LWLockMode)</code></td><td>호출자가 대기 중이 아님을 지정했을 때 LWLock을 성공적으로 획득했을 때 발생하는 프로브입니다. arg0은 LWLock의 트랜치입니다. arg1은 요청된 잠금 모드(독점 또는 공유 중 하나)입니다.</td></tr><tr><td><code class="literal">lwlock-condacquire-fail</code></td><td><code class="literal">(문자 *, LWLockMode)</code></td><td>호출자가 대기 없음을 지정했을 때 LWLock을 성공적으로 획득하지 못했을 때 발생하는 프로브입니다. arg0은 LWLock의 트랜치입니다. arg1은 요청된 잠금 모드(독점 또는 공유 중 하나)입니다.</td></tr><tr><td><code class="literal">lock-wait-start</code></td><td><code class="literal">(부호 없는 int, 부호 없는 int, 부호 없는 int, 부호 없는 int, 부호 없는 int, LOCKMODE)</code></td><td>잠금을 사용할 수 없어 헤비급 잠금(lmgr 잠금) 요청이 대기 시작되었을 때 실행되는 프로브입니다. arg0~arg3은 잠금 중인 객체를 식별하는 태그 필드입니다. arg4는 잠금 중인 객체의 유형을 나타냅니다. arg5는 요청 중인 잠금 유형을 나타냅니다.</td></tr><tr><td><code class="literal">lock-wait-done</code></td><td><code class="literal">(서명되지 않은 int, 서명되지 않은 int, 서명되지 않은 int, 서명되지 않은 int, 서명되지 않은 int, LOCKMODE)</code></td><td>헤비급 잠금(lmgr 잠금) 요청이 대기를 마쳤을 때(즉, 잠금을 획득했을 때) 실행되는 프로브입니다. 인수는 <code class="literal">lock-wait-start와</code> 동일합니다.</td></tr><tr><td><code class="literal">교착 상태 발견</code></td><td><code class="literal">()</code></td><td>데드락 감지기가 데드락을 발견하면 실행되는 프로브.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="TYPEDEFS-TABLE"><p class="title"><strong>표 28.49. 프로브 매개변수에 사용되는 정의된 유형</strong></p><div class="table-contents"><table class="table" summary="Defined Types Used in Probe Parameters" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>유형</th><th>정의</th></tr></thead><tbody><tr><td><code class="type">LocalTransactionId</code></td><td><code class="type">부호 없는 int</code></td></tr><tr><td><code class="type">LWLockMode</code></td><td><code class="type">int</code></td></tr><tr><td><code class="type">LOCKMODE</code></td><td><code class="type">int</code></td></tr><tr><td><code class="type">BlockNumber</code></td><td><code class="type">부호 없는 int</code></td></tr><tr><td><code class="type">Oid</code></td><td><code class="type">부호 없는 int</code></td></tr><tr><td><code class="type">ForkNumber</code></td><td><code class="type">int</code></td></tr><tr><td><code class="type">bool</code></td><td><code class="type">부호 없는 문자</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="USING-TRACE-POINTS"><div class="titlepage"><div><div><h3 class="title">28.5.3. 프로브 <a href="#USING-TRACE-POINTS" class="id_link">#</a> 사용</h3></div></div></div><p>
   아래 예는 성능 테스트 전후에 <code class="structname">pg_stat_database</code> 스냅샷을 생성하는 대신 시스템의 트랜잭션 수를 분석하기 위한 DTrace 스크립트를 보여줍니다:</p><pre class="programlisting">
#!/usr/sbin/dtrace -qs postgresql$1:::transaction-start { @start["Start"] = count(); self-&gt;ts = timestamp; } postgresql$1:::transaction-abort { @abort["Abort"] = count(); } postgresql$1:::transaction-commit /self-&gt;ts/ { @commit["커밋"] = count(); @time["총 시간(ns)"] = sum(timestamp - self-&gt;ts); self-&gt;ts=0; }</pre><p>
   예제 D 스크립트를 실행하면 다음과 같은 출력이 표시됩니다:</p><pre class="screen">
# ./txn_count.d `pgrep -n postgres` 또는 ./txn_count.d &lt;PID&gt; ^C 시작 71 커밋 70 총 시간(ns) 2312105013</pre><p>
  </p><div class="note"><h3 class="title">참고</h3><p>
    기본 추적 지점은 호환되지만 SystemTap은 추적 스크립트에 대해 DTrace와 다른 표기법을 사용합니다.  한 가지 주목할 점은 이 글을 쓰는 시점에서 SystemTap 스크립트는 하이픈 대신 이중 밑줄을 사용하여 프로브 이름을 참조해야 한다는 것입니다.  이 문제는 향후 SystemTap 릴리스에서 수정될 예정입니다.   </p></div><p>
   DTrace 스크립트는 신중하게 작성하고 디버깅해야 하며, 그렇지 않으면 수집된 추적 정보가 의미가 없을 수 있다는 점을 기억해야 합니다. 문제가 발견되는 대부분의 경우 기본 시스템에 문제가 있는 것이 아니라 계측에 문제가 있는 경우가 많습니다. 동적 추적을 사용하여 발견된 정보를 논의할 때는 반드시 해당 정보를 확인하고 논의할 수 있도록 사용된 스크립트를 동봉해야 합니다.  </p></div><div class="sect2" id="DEFINING-TRACE-POINTS"><div class="titlepage"><div><div><h3 class="title">28.5.4. 새 프로브 정의 <a href="#DEFINING-TRACE-POINTS" class="id_link">#</a></h3></div></div></div><p>
   개발자가 원하는 경우 코드 내에서 새 프로브를 정의할 수 있지만, 이 경우 재컴파일이 필요합니다. 다음은 새 프로브를 삽입하는 단계입니다:  </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
     프로브 이름과 프로브를 통해 사용할 수 있는 데이터를 결정합니다.    </p></li><li class="step"><p>
    <code class="filename">src/backend/utils/probes</code>.d에 프로브 정의를 추가합니다.    </p></li><li class="step"><p>
     프로브 지점을 포함하는 모듈에 아직 없는 경우 <code class="filename">pg_trace.h를</code> 포함하고, 소스 코드의 원하는 위치에 <code class="literal">TRACE_POSTGRESQL</code> 프로브 매크로를 삽입합니다.    </p></li><li class="step"><p>
     다시 컴파일하고 새 프로브를 사용할 수 있는지 확인합니다.    </p></li></ol></div><p><strong>예제: </strong>
    다음은 모든 새 트랜잭션을 트랜잭션 ID로 추적하기 위해 프로브를 추가하는 방법의 예입니다.   </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
     프로브의 이름을 <code class="literal">트랜잭션 시작으로</code> 정하고 <code class="type">LocalTransactionId</code>유형의 매개변수가 필요하다고 결정합니다.    </p></li><li class="step"><p>
    <code class="filename">src/backend/utils/probes.d에</code> 프로브 정의를 추가합니다:</p><pre class="programlisting">
프로브 트랜잭션__start(LocalTransactionId);</pre><p>
     프로브 이름에 이중 밑줄을 사용하는 것에 유의하세요. 프로브를 사용하는 DTrace 스크립트에서는 이중 밑줄을 하이픈으로 대체해야 하므로 사용자를 위해 문서화할 이름은 <code class="literal">트랜잭션-start입니다</code>.    </p></li><li class="step"><p>
     컴파일 시 <code class="literal">트랜잭션__start는</code> <code class="literal">TRACE_POSTGRESQL_TRANSACTION_START라는</code> 매크로로 변환되며(여기서는 밑줄이 하나만 있음), <code class="filename">pg_trace.h를</code> 포함하면 이 매크로를 사용할 수 있습니다.  소스 코드의 적절한 위치에 매크로 호출을 추가합니다.  이 경우 다음과 같습니다:</p><pre class="programlisting">
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);</pre><p>
    </p></li><li class="step"><p>
     새 바이너리를 다시 컴파일하고 실행한 후, 다음 DTrace 명령을 실행하여 새로 추가된 프로브를 사용할 수 있는지 확인합니다.  비슷한 출력이 표시될 것입니다:</p><pre class="screen">
# dtrace -ln transaction-start ID 공급자 모듈 함수 이름 18705 postgresql49878 postgres StartTransactionCommand transaction-start 18755 postgresql49877 postgres StartTransactionCommand transaction-.18805 postgresql49876 postgres StartTransactionCommand 트랜잭션 시작 18855 postgres postgres49875 postgres StartTransactionCommand 트랜잭션 시작 18986 postgresql49873 postgres StartTransactionCommand transaction-start</pre><p>
    </p></li></ol></div><p>
   C 코드에 추적 매크로를 추가할 때 주의해야 할 몇 가지 사항이 있습니다:   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      프로브의 매개 변수에 지정된 데이터 유형이 매크로에 사용된 변수의 데이터 유형과 일치하는지 확인해야 합니다. 그렇지 않으면 컴파일 오류가 발생합니다.     </p></li><li class="listitem"><p>
      대부분의 플랫폼에서 <span class="productname">PostgreSQL이</span> <code class="option">--enable-dtrace로</code> 빌드된 경우 <span class="emphasis"><em>추적</em></span> 매크로의 인수는 <span class="emphasis"><em>추적이 수행되고 있지 않더라도</em></span> 제어가 매크로를 통과할 때마다 평가됩니다.  일반적으로 몇 개의 로컬 변수 값만 보고하는 경우에는 걱정할 필요가 없습니다.  하지만 값비싼 함수 호출을 인수에 넣는 것은 주의하세요.  이 작업을 수행해야 하는 경우 추적이 실제로 활성화되어 있는지 확인하여 매크로를 보호하는 것이 좋습니다:</p><pre class="programlisting">
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED()) TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));</pre><p>

      각 추적 매크로에는 해당 <code class="literal">ENABLED</code> 매크로가 있습니다.     </p></li></ul></div><p>

  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="progress-reporting.html" title="28.4. Progress Reporting">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="monitoring.html" title="Chapter 28. Monitoring Database Activity">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="diskusage.html" title="Chapter 29. Monitoring Disk Usage">다음</a></td></tr><tr><td width="40%" align="left" valign="top">28.4. 진행 상황 보고 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="40%" align="right" valign="top"> 29장. 디스크 사용량 모니터링</td></tr></table></div></body></html>