<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.8. 부분 색인</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="indexes-expressional.html" title="11.7. Indexes on Expressions" /><link rel="next" href="indexes-index-only-scans.html" title="11.9. Index-Only Scans and Covering Indexes" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.8. 부분 색인</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-expressional.html" title="11.7. Indexes on Expressions">이전</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Chapter 11. Indexes">위로</a></td><th width="60%" align="center">11장 색인</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-index-only-scans.html" title="11.9. Index-Only Scans and Covering Indexes">다음</a></td></tr></table><hr /></div><div class="sect1" id="INDEXES-PARTIAL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.8. 부분 인덱스 <a href="#INDEXES-PARTIAL" class="id_link">#</a></h2></div></div></div><a id="id-1.5.10.11.2" class="indexterm"></a><p>
   부분 <em class="firstterm">인덱스는</em> 테이블의 하위 집합 위에 구축된 인덱스로, 하위 집합은 조건식(부분 인덱스의 <em class="firstterm">술어라고</em> 함)에 의해 정의됩니다.  이 인덱스에는 술어를 만족하는 테이블 행에 대한 항목만 포함됩니다.  부분 인덱스는 특수한 기능이지만, 부분 인덱스가 유용한 상황에는 여러 가지가 있습니다.  </p><p>
   부분 인덱스를 사용하는 주된 이유 중 하나는 공통 값의 인덱싱을 피하기 위해서입니다.  공통 값(전체 테이블 행의 몇 퍼센트 이상을 차지하는 값)을 검색하는 쿼리는 어차피 인덱스를 사용하지 않으므로 이러한 행을 인덱스에 보관할 필요가 전혀 없습니다.  이렇게 하면 인덱스의 크기가 줄어들어 인덱스를 사용하는 쿼리의 속도가 빨라집니다.  또한 모든 경우에 인덱스를 업데이트할 필요가 없으므로 많은 테이블 업데이트 작업의 속도도 빨라집니다. <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX1" title="Example 11.1. Setting up a Partial Index to Exclude Common Values">예 11.1은</a> 이 아이디어의 적용 가능성을 보여줍니다.  </p><div class="example" id="INDEXES-PARTIAL-EX1"><p class="title"><strong>예 11.1. 공통 값을 제외하도록 부분 인덱스 설정하기</strong></p><div class="example-contents"><p>
    웹 서버 액세스 로그를 데이터베이스에 저장한다고 가정해 보겠습니다. 대부분의 액세스는 조직의 IP 주소 범위에서 시작되지만 일부는 다른 곳(예: 전화 접속을 사용하는 직원)에서 발생합니다. IP로 검색하는 것이 주로 외부 액세스에 대한 것이라면 조직의 서브넷에 해당하는 IP 범위를 색인할 필요가 없을 수도 있습니다.   </p><p>
    다음과 같은 테이블을 가정해 보겠습니다:</p><pre class="programlisting">
CREATE TABLE access_log ( url varchar, client_ip inet, ... );</pre><p>
   </p><p>
    이 예제에 적합한 부분 인덱스를 만들려면 다음과 같은 명령을 사용합니다:</p><pre class="programlisting">
CREATE INDEX access_log_client_ip_ix ON access_log (client_ip) WHERE NOT (client_ip &gt; inet '192.168.100.0' AND client_ip &lt; inet '192.168.100.255');</pre><p>
   </p><p>
    이 인덱스를 사용할 수 있는 일반적인 쿼리는 다음과 같습니다:</p><pre class="programlisting">
SELECT * FROM access_log WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';</pre><p>
    여기서 쿼리의 IP 주소는 부분 인덱스에 포함됩니다.  다음 쿼리는 인덱스에서 제외된 IP 주소를 사용하므로 부분 인덱스를 사용할 수 없습니다:</p><pre class="programlisting">
SELECT * FROM access_log WHERE url = '/index.html' AND client_ip = inet '192.168.100.23';</pre><p>
   </p><p>
    이러한 종류의 부분 인덱스는 공통 값을 미리 결정해야 하므로 이러한 부분 인덱스는 변경되지 않는 데이터 배포에 사용하는 것이 가장 좋습니다.  이러한 인덱스는 새로운 데이터 분포에 맞게 조정하기 위해 가끔 다시 만들 수 있지만 유지 관리 작업이 추가됩니다.   </p></div></div><br class="example-break" /><p>
   부분 인덱스의 또 다른 가능한 용도는 일반적인 쿼리 워크로드에서 관심이 없는 값을 인덱스에서 제외하는 것입니다( <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX2" title="Example 11.2. Setting up a Partial Index to Exclude Uninteresting Values">예 11.2에</a> 나와 있음).  이렇게 하면 위에 나열된 것과 동일한 이점이 있지만, 인덱스 스캔이 수익성이 있을 수 있는 경우에도 해당 인덱스를 통해 " <span class="quote"><span class="quote">관심 없는</span>"</span> 값에 액세스할 수 없게 됩니다.  물론 이런 종류의 시나리오를 위해 부분 인덱스를 설정하려면 많은 주의와 실험이 필요합니다.  </p><div class="example" id="INDEXES-PARTIAL-EX2"><p class="title"><strong>예 11.2. 관심 없는 값을 제외하도록 부분 인덱스 설정하기</strong></p><div class="example-contents"><p>
    청구된 주문과 청구되지 않은 주문이 모두 포함된 테이블이 있고, 청구되지 않은 주문이 전체 테이블에서 차지하는 비중이 작지만 가장 많이 액세스되는 행인 경우, 청구되지 않은 행만 인덱스를 생성하여 성능을 개선할 수 있습니다.  인덱스를 생성하는 명령은 다음과 같습니다:</p><pre class="programlisting">
CREATE INDEX orders_unbilled_index ON orders (order_nr) WHERE billed가 true가 아닌 경우;</pre><p>
   </p><p>
    이 인덱스를 사용할 수 있는 쿼리는 다음과 같습니다:</p><pre class="programlisting">
SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000입니다;</pre><p>
    그러나 이 인덱스는 다음과 같이 <code class="structfield">order_nr이</code> 전혀 포함되지 않는 쿼리에도 사용할 수 있습니다:</p><pre class="programlisting">
SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;</pre><p>
    이것은 시스템이 전체 인덱스를 스캔해야 하므로 <code class="structfield">금액</code> 열의 부분 인덱스만큼 효율적이지 않습니다.  그러나 미청구 주문이 상대적으로 적은 경우에는 이 부분 인덱스를 사용하여 미청구 주문을 찾는 것이 유리할 수 있습니다.   </p><p>
    이 쿼리에서는 이 인덱스를 사용할 수 없습니다:</p><pre class="programlisting">
SELECT * FROM orders WHERE order_nr = 3501;</pre><p>
    주문 3501은 청구된 주문 또는 청구되지 않은 주문 중 하나일 수 있습니다.   </p></div></div><br class="example-break" /><p>
   또한 <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX2" title="Example 11.2. Setting up a Partial Index to Exclude Uninteresting Values">예 11.2는</a> 인덱싱된 열과 술어에 사용된 열이 일치할 필요가 없음을 보여줍니다. <span class="productname">PostgreSQL은</span> 인덱싱되는 테이블의 열만 관련된 경우 임의의 술어가 포함된 부분 인덱스를 지원합니다.  그러나 술어는 인덱스의 이점을 활용해야 하는 쿼리에 사용되는 조건과 일치해야 한다는 점에 유의하세요.  정확히 말하면, 부분 인덱스는 쿼리의 <code class="literal">WHERE</code> 조건이 인덱스의 술어를 수학적으로 암시한다는 것을 시스템이 인식할 수 있는 경우에만 쿼리에서 사용할 수 있습니다. <span class="productname">PostgreSQL에는</span> 다른 형식으로 작성된 수학적으로 동일한 식을 인식할 수 있는 정교한 정리 증명자가 없습니다.  (이러한 일반적인 정리 증명자는 만들기가 매우 어려울 뿐만 아니라 속도가 너무 느려서 실제로 사용할 수 없습니다.) 시스템은 간단한 부등식의 함축(예: " <span class="quote"><span class="quote">x &lt; 1</span>"</span> 은 <span class="quote">"<span class="quote">x &lt; 2</span></span>"를 의미함)을 인식할 수 있지만, 그렇지 않으면 술어 조건이 쿼리의 <code class="literal">WHERE</code> 조건의 일부와 정확히 일치해야 하거나 인덱스가 사용 가능한 것으로 인식되지 않습니다. 매칭은 실행 시간이 아니라 쿼리 계획 시점에 이루어집니다. 따라서 매개변수화된 쿼리 절은 부분 인덱스에서는 작동하지 않습니다. 예를 들어 매개변수가 있는 준비된 쿼리는 " <span class="quote"><span class="quote">x &lt; ?</span>"</span> 를 지정할 수 있지만, 이는 매개변수의 가능한 모든 값에 대해 " <span class="quote"><span class="quote">x &lt; 2</span></span> "를 의미하지 않습니다.  </p><p>
   부분 인덱스의 세 번째 가능한 용도는 쿼리에 인덱스를 전혀 사용할 필요가 없는 것입니다.  여기서는 <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX3" title="Example 11.3. Setting up a Partial Unique Index">예 11.3에서와</a> 같이 테이블의 하위 집합에 대해 고유 인덱스를 생성하는 것입니다.  이렇게 하면 인덱스 술어를 만족하는 행 간에 고유성을 적용하고 그렇지 않은 행은 제한하지 않습니다.  </p><div class="example" id="INDEXES-PARTIAL-EX3"><p class="title"><strong>예 11.3. 부분 고유 인덱스 설정</strong></p><div class="example-contents"><p>
    테스트 결과를 설명하는 테이블이 있다고 가정해 보겠습니다.  주어진 주제와 대상 조합에 대해 <span class="quote">"<span class="quote">성공한</span>"</span> 항목은 하나만 있지만 " <span class="quote"><span class="quote">실패한</span></span> " 항목은 얼마든지 있을 수 있습니다.  다음은 이를 수행하는 한 가지 방법입니다:</p><pre class="programlisting">
CREATE TABLE tests ( 제목 텍스트, 대상 텍스트, 성공 부울, ... ); CREATE UNIQUE INDEX tests_success_constraint ON tests (제목, 대상) WHERE success;</pre><p>
    이 방법은 성공한 테스트가 적고 실패한 테스트가 많은 경우에 특히 효율적인 접근 방식입니다. <code class="literal">IS NULL</code> 제한이 있는 고유한 부분 인덱스를 생성하여 열에 하나의 null만 허용할 수도 있습니다.   </p></div></div><br class="example-break" /><p>
   마지막으로, 부분 인덱스를 사용하여 시스템의 쿼리 계획 선택을 재정의할 수도 있습니다.  또한, 특이한 분포를 가진 데이터 세트는 시스템에서 실제로 사용해서는 안 되는 인덱스를 사용하게 만들 수 있습니다.  이 경우 문제가 되는 쿼리에 사용할 수 없도록 인덱스를 설정할 수 있습니다.  일반적으로 <span class="productname">PostgreSQL은</span> 인덱스 사용에 대해 합리적인 선택을 하며(예: 일반적인 값을 검색할 때 이를 피하므로 앞의 예는 실제로 인덱스 크기만 절약하고 인덱스 사용을 피할 필요는 없음), 심하게 잘못된 계획 선택은 버그 보고의 원인이 됩니다.  </p><p>
   부분 인덱스를 설정한다는 것은 적어도 쿼리 플래너가 알고 있는 만큼, 특히 인덱스가 수익성이 있을 수 있는 시기를 알고 있다는 것을 의미한다는 것을 명심하세요.  이러한 지식을 형성하려면 <span class="productname">PostgreSQL의</span> 인덱스 작동 방식에 대한 경험과 이해가 필요합니다.  대부분의 경우, 일반 인덱스에 비해 부분 인덱스의 이점은 미미합니다. <a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX4" title="Example 11.4. Do Not Use Partial Indexes as a Substitute for Partitioning">예 11.4에서와</a> 같이 오히려 역효과가 나는 경우도 있습니다.  </p><div class="example" id="INDEXES-PARTIAL-EX4"><p class="title"><strong>예 11.4. 부분 인덱스를 파티셔닝의 대체물로 사용하지 않기</strong></p><div class="example-contents"><p>
    다음과 같이 겹치지 않는 부분 인덱스의 큰 집합을 만들고 싶은 유혹을 받을 수 있습니다.</p><pre class="programlisting">
CREATE INDEX mytable_cat_1 ON mytable (데이터) WHERE category = 1; CREATE INDEX mytable_cat_2 ON mytable (데이터) WHERE category = 2; CREATE INDEX mytable_cat_3 ON mytable (데이터) WHERE category = 3; ... CREATE INDEX <em class="replaceable"><code>mytable_cat_N</code></em> ON mytable (데이터) WHERE category = <em class="replaceable"><code>N</code></em>...;</pre><p>

    이것은 나쁜 생각입니다!  거의 확실하게, 다음과 같이 선언된 부분 인덱스가 아닌 단일 인덱스를 사용하는 것이 더 나을 것입니다.</p><pre class="programlisting">
CREATE INDEX mytable_cat_data ON mytable (category, data);</pre><p>

    ( <a class="xref" href="indexes-multicolumn.html" title="11.3. Multicolumn Indexes">11.3절에</a> 설명된 이유 때문에 카테고리 열을 먼저 넣습니다.)  이 큰 인덱스에서의 검색은 작은 인덱스에서의 검색보다 몇 개의 트리 레벨을 더 내려가야 할 수도 있지만, 부분 인덱스 중 적절한 것을 선택하는 데 필요한 플래너의 노력보다는 거의 확실하게 저렴할 것입니다.  문제의 핵심은 시스템이 부분 인덱스 간의 관계를 이해하지 못하고, 각 인덱스가 현재 쿼리에 적용 가능한지 확인하기 위해 힘들게 테스트한다는 것입니다.   </p><p>
    테이블이 너무 커서 단일 인덱스를 사용하는 것이 정말 좋지 않은 경우, 대신 파티셔닝을 사용하는 것을 고려해야 합니다( <a class="xref" href="ddl-partitioning.html" title="5.11. Table Partitioning">5.11절</a> 참조).  이 메커니즘을 사용하면 시스템이 테이블과 인덱스가 겹치지 않는다는 것을 이해하므로 훨씬 더 나은 성능을 얻을 수 있습니다.   </p></div></div><br class="example-break" /><p>
   부분 인덱스에 대한 자세한 내용은 <a class="xref" href="biblio.html#STON89B">[ston89b]</a>, <a class="xref" href="biblio.html#OLSON93" title="Partial indexing in POSTGRES: research project">[olson93</a>], <a class="xref" href="biblio.html#SESHADRI95">[seshadri95</a>]에서 확인할 수 있습니다.  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-expressional.html" title="11.7. Indexes on Expressions">이전</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html" title="Chapter 11. Indexes">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-index-only-scans.html" title="11.9. Index-Only Scans and Covering Indexes">다음</a></td></tr><tr><td width="40%" align="left" valign="top">11.7. 표현식에 대한 색인 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="40%" align="right" valign="top"> 11.9. 색인 전용 스캔 및 커버링 색인</td></tr></table></div></body></html>