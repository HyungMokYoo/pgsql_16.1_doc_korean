<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>분석</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="sql-alterview.html" title="ALTER VIEW" /><link rel="next" href="sql-begin.html" title="BEGIN" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">분석</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-alterview.html" title="ALTER VIEW">이전</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQL Commands">위로</a></td><th width="60%" align="center">SQL 명령</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-begin.html" title="BEGIN">다음</a></td></tr></table><hr /></div><div class="refentry" id="SQL-ANALYZE"><div class="titlepage"></div><a id="id-1.9.3.46.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">ANALYZE</span></h2><p>분석 - 데이터베이스에 대한 통계 수집</p></div><div class="refsynopsisdiv"><h2>개요</h2><pre class="synopsis">
ANALYZE [ ( <em class="replaceable"><code>옵션</code></em> [, ...] ) ] ] [ <em class="replaceable"><code>table_and_columns</code></em> [, ...] ] ANALYZE [ VERBOSE ] [ <em class="replaceable"><code>table_and_columns</code></em> [, ...] ]<span class="phrase">여기서 <em class="replaceable"><code>옵션은</code></em></span>VERBOSE [ <em class="replaceable"><code>boolean</code></em> ] SKIP_LOCKED [ <em class="replaceable"><code>boolean</code></em> ] BUFFER_USAGE_LIMIT<span class="phrase">크기이고 <em class="replaceable"><code>table_and_columns</code></em> 는</span> <em class="replaceable"><code>table_name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ]입니다.</pre></div><div class="refsect1" id="id-1.9.3.46.5"><h2>설명</h2><p>
  <code class="command">분석은</code> 데이터베이스 내 테이블의 내용에 대한 통계를 수집하고 그 결과를 <a class="link" href="catalog-pg-statistic.html" title="53.51. pg_statistic"><code class="structname">pg_statistic</code></a>시스템 카탈로그에 저장합니다.  이후 쿼리 플래너는 이러한 통계를 사용하여 쿼리에 대한 가장 효율적인 실행 계획을 결정합니다.  </p><p>
  <em class="replaceable"><code>table_and_columns</code></em>목록이 없으면 현재 사용자가 분석 권한이 있는 현재 데이터베이스의 모든 테이블과 구체화된 뷰를 처리하고, 목록이 있으면 해당 테이블만 처리합니다. 또한 테이블의 열 이름 목록을 제공할 수 있으며, 이 경우 해당 열에 대한 통계만 수집됩니다.  </p><p>
   옵션 목록이 괄호로 둘러싸인 경우 옵션은 어떤 순서로든 작성할 수 있습니다.  괄호로 묶인 구문은 <span class="productname">PostgreSQL</span> 11에 추가되었으며, 괄호로 묶이지 않은 구문은 더 이상 사용되지 않습니다.  </p></div><div class="refsect1" id="id-1.9.3.46.6"><h2>파라미터</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">VERBOSE</code></span></dt><dd><p>
      진행률 메시지 표시를 활성화합니다.     </p></dd><dt><span class="term"><code class="literal">SKIP_LOCKED</code></span></dt><dd><p>
     <code class="command">관계에</code> 대한 작업을 시작할 때 충돌하는 잠금이 해제될 때까지 기다리지 않도록 지정합니다. 즉, 기다리지 않고 즉시 잠글 수 없는 관계는 건너뜁니다.  이 옵션을 사용하더라도 관계의 인덱스를 열거나 파티션, 테이블 상속 자식 및 일부 유형의 외부 테이블에서 샘플 행을 가져올 때 <code class="command">ANALYZE가</code>여전히 차단될 수 있습니다.  또한 일반적으로 <code class="command">분석은</code>지정된 파티션 테이블의 모든 파티션을 처리하지만, 이 옵션을 사용하면 파티션 테이블에 충돌하는 잠금이 있는 경우 <code class="command">분석이</code> 모든 파티션을 건너뛰게 됩니다.     </p></dd><dt><span class="term"><code class="literal">BUFFER_USAGE_LIMIT</code></span></dt><dd><p>
     <code class="command">분석에</code> 대한 <a class="glossterm" href="glossary.html#GLOSSARY-BUFFER-ACCESS-STRATEGY"><em class="glossterm"><a class="glossterm" href="glossary.html#GLOSSARY-BUFFER-ACCESS-STRATEGY" title="Buffer Access Strategy">버퍼 액세스 전략</a></em></a>링 버퍼 크기를 지정합니다.  이 크기는 이 전략의 일부로 재사용될 공유 버퍼의 수를 계산하는 데 사용됩니다. <code class="literal">0은</code> <code class="literal">버퍼 액세스 전략의</code> 사용을 비활성화합니다.   이 옵션이 지정되지 않은 경우, <code class="command">ANALYZE는</code> <a class="xref" href="runtime-config-resource.html#GUC-VACUUM-BUFFER-USAGE-LIMIT">vacuum_buffer_usage_limit의</a> 값을 사용합니다.  설정이 높을수록 <code class="command">분석이</code> 더 빨리 실행될 수 있지만, 설정이 너무 크면 공유 버퍼에서 다른 유용한 페이지가 너무 많이 제거될 수 있습니다.  최소값은 <code class="literal">128kB이고</code> 최대값은 <code class="literal">16GB입니다</code>.     </p></dd><dt><span class="term"><em class="replaceable"><code>부울</code></em></span></dt><dd><p>
      선택한 옵션을 켜거나 끌지 여부를 지정합니다. 옵션을 활성화하려면 <code class="literal">TRUE</code>, <code class="literal">ON</code> 또는 <code class="literal">1을</code>, 비활성화하려면 <code class="literal">FALSE</code>, <code class="literal">OFF</code> 또는 <code class="literal">0을</code> 입력할 수 있습니다. <em class="replaceable"><code>부울</code></em> 값은 생략할 수도 있으며, 이 경우 <code class="literal">TRUE가</code> 가정됩니다.     </p></dd><dt><span class="term"><em class="replaceable"><code>size</code></em></span></dt><dd><p>
      메모리 양을 킬로바이트 단위로 지정합니다.  크기는 숫자 크기 뒤에 다음 메모리 단위 중 하나를 포함하는 문자열로 지정할 수도 있습니다: <code class="literal">B</code> (바이트), <code class="literal">kB</code> (킬로바이트), <code class="literal">MB</code> (메가바이트), <code class="literal">GB</code> (기가바이트) 또는 <code class="literal">TB</code> (테라바이트).     </p></dd><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>
      분석할 특정 테이블의 이름(스키마로 한정된 이름일 수 있음)입니다.  생략하면 현재 데이터베이스의 모든 일반 테이블, 파티션된 테이블 및 구체화된 뷰가 분석됩니다(외부 테이블은 분석되지 않음).  지정한 테이블이 분할된 테이블인 경우 분할된 테이블 전체의 상속 통계와 개별 분할의 통계가 모두 업데이트됩니다.     </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p>
      분석할 특정 열의 이름입니다. 기본값은 모든 열입니다.     </p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.46.7"><h2>출력</h2><p>
   <code class="command">VERBOSE를</code> 지정하면 현재 처리 중인 테이블을 나타내는 진행률 메시지를 출력합니다.  테이블에 대한 다양한 통계도 인쇄됩니다.   </p></div><div class="refsect1" id="id-1.9.3.46.8"><h2>참고 사항</h2><p>
   테이블을 분석하려면 일반적으로 테이블의 소유자 또는 수퍼유저여야 합니다.  그러나 데이터베이스 소유자는 공유 카탈로그를 제외한 데이터베이스의 모든 테이블을 분석할 수 있습니다. (공유 카탈로그에 대한 제한으로 인해 진정한 데이터베이스 전체 <code class="command">분석은</code> 슈퍼유저만 수행할 수 있습니다.) <code class="command">분석은</code> 호출 사용자에게 분석 권한이 없는 모든 테이블을 건너뜁니다.  </p><p>
   외부 테이블은 명시적으로 선택한 경우에만 분석됩니다.  모든 외부 데이터 래퍼가 <code class="command">ANALYZE를</code> 지원하는 것은 아닙니다.  테이블의 래퍼가 <code class="command">ANALYZE를</code> 지원하지 않는 경우, 명령은 경고를 출력하고 아무 작업도 수행하지 않습니다.  </p><p>
   기본 <span class="productname">PostgreSQL</span> 구성에서는 자동 진공 데몬( <a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. The Autovacuum Daemon">섹션 25.1.6</a> 참조)이 테이블에 데이터가 처음 로드될 때와 일반 작업 중에 변경될 때 자동 분석을 처리합니다. 자동 진공을 비활성화하면 주기적으로 또는 테이블의 내용을 크게 변경한 직후에 <code class="command">ANALYZE를</code> 실행하는 것이 좋습니다.  정확한 통계는 계획자가 가장 적절한 쿼리 계획을 선택하는 데 도움이 되며, 따라서 쿼리 처리 속도를 향상시킬 수 있습니다.  읽기 위주의 데이터베이스에 대한 일반적인 전략은 사용량이 적은 시간대에 하루에 한 번씩 <a class="link" href="sql-vacuum.html" title="VACUUM"><code class="command">VACUUM</code></a>및 <code class="command">ANALYZE를</code> 실행하는 것입니다. (업데이트 작업이 많은 경우에는 이 방법으로는 충분하지 않습니다.)  </p><p>
  <code class="command">분석에는</code>대상 테이블에 대한 읽기 잠금만 필요하므로 테이블의 다른 활동과 병렬로 실행할 수 있습니다.  </p><p>
  <code class="command">분석에서</code> 수집한 통계에는 일반적으로 각 열에서 가장 일반적인 값의 목록과 각 열의 대략적인 데이터 분포를 보여주는 히스토그램이 포함됩니다.  이 중 하나 또는 둘 다는 <code class="command">분석에서</code> 흥미롭지 않다고 판단하거나(예: 고유 키 열에 공통 값이 없는 경우) 열 데이터 유형이 적절한 연산자를 지원하지 않는 경우 생략할 수 있습니다.  통계에 대한 자세한 내용은 <a class="xref" href="maintenance.html" title="Chapter 25. Routine Database Maintenance Tasks">25장에</a> 나와 있습니다.  </p><p>
   큰 테이블의 경우 <code class="command">분석은</code> 모든 행을 검사하지 않고 테이블 내용의 무작위 샘플을 가져옵니다.  따라서 매우 큰 테이블도 짧은 시간 내에 분석할 수 있습니다.  그러나 통계는 근사치일 뿐이며 실제 테이블 내용이 변경되지 않았더라도 <code class="command">분석을</code> 실행할 때마다 약간씩 변경된다는 점에 유의하세요.  이로 인해 <a class="link" href="sql-explain.html" title="EXPLAIN"><code class="command">EXPLAIN에</code></a> 표시되는 플래너의 예상 비용이 약간 변경될 수 있습니다. 드물지만 이러한 비결정성으로 인해 플래너가 선택한 쿼리 계획이 <code class="command">ANALYZE</code> 실행 후 변경될 수 있습니다. 이를 방지하려면 아래 설명된 대로 <code class="command">ANALYZE에서</code> 수집하는 통계의 양을 늘리세요.  </p><p>
   분석 범위는 <a class="xref" href="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a> 구성 변수를 조정하여 제어하거나 열 단위로 열별 통계 대상을 설정하여 열 단위로 <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE ... ALTER COLUMN ... 통계 설정</code></a>. 목표 값은 가장 일반적인 값 목록의 최대 항목 수와 히스토그램의 최대 구간차원 수를 설정합니다.  기본 목표 값은 100이지만 플래너 추정치의 정확도와 <code class="command">분석에</code> 걸리는 시간 및 <code class="literal">pg_statistic에서</code> 차지하는 공간의 양을 비교하여 이 값을 높이거나 낮출 수 있습니다.  특히 통계 대상을 0으로 설정하면 해당 열에 대한 통계 수집이 비활성화됩니다.  플래너는 이러한 열에 대한 통계를 사용할 수 없으므로 쿼리의 <code class="literal">WHERE</code>, <code class="literal">GROUP BY</code> 또는 <code class="literal">ORDER BY</code> 절의 일부로 사용되지 않는 열의 경우 이렇게 설정하는 것이 유용할 수 있습니다.  </p><p>
   분석 중인 열 중 가장 큰 통계 대상에 따라 통계 준비를 위해 샘플링되는 테이블 행의 수가 결정됩니다.  대상을 늘리면 <code class="command">분석을</code> 수행하는 데 필요한 시간과 공간이 비례적으로 증가합니다.  </p><p>
  <code class="command">분석에서</code> 추정하는 값 중 하나는 각 열에 나타나는 고유 값의 수입니다.  행의 하위 집합만 검사하기 때문에 가능한 가장 큰 통계 대상을 사용하더라도 이 추정치는 때때로 상당히 부정확할 수 있습니다.  이러한 부정확성으로 인해 잘못된 쿼리 계획으로 이어지는 경우 보다 정확한 값을 수동으로 결정한 다음 <a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)</code></a>.  </p><p>
    분석 중인 테이블에 상속 자식이 있는 경우 <code class="command">분석은</code> 부모 테이블의 행에 대한 통계만 수집하고, 부모 테이블과 모든 자식의 행을 포함하는 두 번째 통계 집합을 수집합니다.  이 두 번째 통계 세트는 상속 트리 전체를 처리하는 쿼리를 계획할 때 필요합니다.  이 경우 자식 테이블 자체는 개별적으로 분석되지 않습니다. 그러나 자동 진공 디먼은 해당 테이블에 대한 자동 분석을 트리거할지 여부를 결정할 때 부모 테이블 자체의 삽입 또는 업데이트만 고려합니다.  해당 테이블이 거의 삽입되거나 업데이트되지 않는 경우, 수동으로 <code class="command">분석을</code> 실행하지 않는 한 상속 통계가 최신 상태가 되지 않습니다.  </p><p>
    분할된 테이블의 경우, <code class="command">분석은</code> 모든 파티션에서 행을 샘플링하여 통계를 수집하고, 각 파티션으로 재귀하여 통계를 업데이트합니다.  각 리프 파티션은 다단계 파티셔닝을 사용하더라도 한 번만 분석됩니다.  파티셔닝을 사용하면 파티션이 비어 있는 것이 보장되므로 상위 테이블(해당 파티션의 데이터가 없는)에 대해서만 통계가 수집되지 않습니다.  </p><p>
    자동 진공 디먼은 파티션된 테이블을 처리하지 않으며, 자식만 수정된 경우 상속 부모도 처리하지 않습니다. 일반적으로 테이블 계층의 통계를 최신 상태로 유지하려면 수동 <code class="command">분석을</code> 주기적으로 실행해야 합니다.  </p><p>
    자식 테이블 또는 파티션이 외부 데이터 래퍼가 <code class="command">ANALYZE를</code> 지원하지 않는 외부 테이블인 경우, 상속 통계를 수집하는 동안 해당 테이블은 무시됩니다.  </p><p>
    분석 중인 테이블이 완전히 비어 있는 경우, <code class="command">분석은</code>해당 테이블에 대한 새 통계를 기록하지 않습니다.  기존 통계는 모두 유지됩니다.  </p><p>
   <code class="command">분석을</code> 실행하는 각 백엔드는 <code class="structname">pg_stat_progress_analyze</code> 뷰에서 진행 상황을 보고합니다. 자세한 내용은 <a class="xref" href="progress-reporting.html#ANALYZE-PROGRESS-REPORTING" title="28.4.1. ANALYZE Progress Reporting">섹션 28.4.1을</a> 참조하세요.  </p></div><div class="refsect1" id="id-1.9.3.46.9"><h2>호환성</h2><p>
   SQL 표준에는 <code class="command">ANALYZE</code> 문이 없습니다.  </p></div><div class="refsect1" id="id-1.9.3.46.10"><h2>참고 항목</h2><span class="simplelist"><a class="xref" href="sql-vacuum.html" title="VACUUM"><span class="refentrytitle">VACUUM</span></a>, <a class="xref" href="app-vacuumdb.html" title="vacuumdb"><span class="refentrytitle"><span class="application">vacuumdb</span></span></a>, <a class="xref" href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST" title="20.4.4. Cost-based Vacuum Delay">섹션 20.4</a>.4, 섹션 <a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="25.1.6. The Autovacuum Daemon">25.1.6</a>, <a class="xref" href="progress-reporting.html#ANALYZE-PROGRESS-REPORTING" title="28.4.1. ANALYZE Progress Reporting">섹션 28.4.1</a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-alterview.html" title="ALTER VIEW">이전</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html" title="SQL Commands">위로</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-begin.html" title="BEGIN">다음</a></td></tr><tr><td width="40%" align="left" valign="top">보기 변경 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="40%" align="right" valign="top"> BEGIN</td></tr></table></div></body></html>