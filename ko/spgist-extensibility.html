<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>69.3. 확장성</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="spgist-builtin-opclasses.html" title="69.2. Built-in Operator Classes" /><link rel="next" href="spgist-implementation.html" title="69.4. Implementation" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">69.3. 확장성</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="spgist-builtin-opclasses.html" title="69.2. Built-in Operator Classes">이전</a> </td><td width="10%" align="left"><a accesskey="u" href="spgist.html" title="Chapter 69. SP-GiST Indexes">Up</a></td><th width="60%" align="center">69장 SP-GiST 인덱스</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="10%" align="right"> <a accesskey="n" href="spgist-implementation.html" title="69.4. Implementation">다음</a></td></tr></table><hr /></div><div class="sect1" id="SPGIST-EXTENSIBILITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">69.3. 확장성</h2></div></div></div><p>
 <acronym class="acronym">SP-GiST는</acronym> 높은 수준의 추상화 인터페이스를 제공하므로 액세스 메서드 개발자는 주어진 데이터 유형에 특정한 메서드만 구현하면 됩니다. <acronym class="acronym">SP-GiST</acronym> 코어는 효율적인 디스크 매핑과 트리 구조 검색을 담당하며, 동시성 및 로깅 고려 사항도 처리합니다. </p><p>
 <acronym class="acronym">SP-GiST</acronym> 트리의 리프 튜플은 일반적으로 색인된 열과 동일한 데이터 유형의 값을 포함하지만, 색인된 열의 손실된 표현을 포함할 수도 있습니다. 루트 레벨에 저장된 리프 튜플은 원래 색인된 데이터 값을 직접 나타내지만 하위 레벨의 리프 튜플은 접미사와 같은 일부 값만 포함할 수 있습니다. 이 경우 오퍼레이터 클래스 지원 함수는 리프 레벨에 도달하기 위해 통과되는 내부 튜플에서 축적된 정보를 사용하여 원래 값을 재구성할 수 있어야 합니다. </p><p>
 <code class="literal">INCLUDE</code> 컬럼으로 <acronym class="acronym">SP-GiST</acronym> 인덱스가 생성되면 해당 컬럼의 값도 리프 튜플에 저장됩니다. <code class="literal">INCLUDE</code> 열은 <acronym class="acronym">SP-GiST</acronym> 연산자 클래스와 관련이 없으므로 여기서는 더 이상 설명하지 않습니다. </p><p>
  내부 튜플은 검색 트리의 분기점이기 때문에 더 복잡합니다.  각 내부 튜플은 유사한 리프 값의 그룹을 나타내는 하나 이상의 <em class="firstterm">노드</em> 집합을 포함합니다. 노드에는 다른 하위 수준의 내부 튜플로 연결되거나 모두 동일한 색인 페이지에 있는 리프 튜플의 짧은 목록으로 연결되는 다운링크가 있습니다. 각 노드에는 일반적으로 이를 설명하는 <em class="firstterm">레이블이</em> 있습니다(예: 기수 트리에서 노드 레이블은 문자열 값의 다음 문자일 수 있음).  (또는 연산자 클래스가 모든 내부 튜플에 대해 고정된 노드 집합으로 작동하는 경우 노드 레이블을 생략할 수 있습니다. <a class="xref" href="spgist-implementation.html#SPGIST-NULL-LABELS" title="69.4.2. SP-GiST Without Node Labels">69.4.2절</a> 참조) 선택적으로, 내부 튜플은 모든 멤버를 설명하는 <em class="firstterm">접두사</em> 값을 가질 수 있습니다.  기수 트리에서 이것은 표현된 문자열의 공통 접두사가 될 수 있습니다.  접두사 값은 반드시 접두사일 필요는 없지만 연산자 클래스에서 필요로 하는 모든 데이터가 될 수 있습니다. 예를 들어 쿼드 트리에서는 네 개의 사분면이 측정되는 중심점을 저장할 수 있습니다.  그러면 쿼드 트리 내부 튜플에는 이 중심점 주변의 사분면에 해당하는 4개의 노드도 포함됩니다. </p><p>
  일부 트리 알고리즘은 현재 튜플의 레벨(또는 깊이)에 대한 지식이 필요하므로 <acronym class="acronym">SP-GiST</acronym> 코어는 오퍼레이터 클래스가 트리를 하강하는 동안 레벨 카운트를 관리할 수 있는 기능을 제공합니다. 또한 필요한 경우 표현된 값을 점진적으로 재구성하고 트리 하강 중에 추가 데이터( <em class="firstterm">트래버스 값이라고</em> 함)를 전달할 수 있는 기능도 지원됩니다. </p><div class="note"><h3 class="title">참고</h3><p>
  <acronym class="acronym">SP-GiST</acronym> 핵심 코드는 null 항목을 처리합니다. <acronym class="acronym">SP-GiST</acronym> 인덱스는 색인된 열에 null 항목을 저장하지만, 이는 인덱스 연산자 클래스 코드에서 숨겨져 있습니다. 어떤 null 인덱스 항목이나 검색 조건도 연산자 클래스 메서드에 전달되지 않습니다.  ( <acronym class="acronym">SP-GiST</acronym>연산자는 엄격하므로 null 값에 대해 성공할 수 없다고 가정합니다.)  따라서 여기서는 null 값에 대해서는 더 이상 설명하지 않습니다.  </p></div><p>
 <acronym class="acronym">SP-GiST용</acronym> 인덱스 연산자 클래스가 제공해야 하는 사용자 정의 메서드는 5가지가 있으며, 2가지 메서드는 선택 사항입니다.  5개의 필수 메서드는 모두 두 개의 <code class="type">내부</code>인자를 받는 규칙을 따르는데, 첫 번째 인자는 지원 메서드의 입력 값을 포함하는 C 구조체에 대한 포인터이고, 두 번째 인자는 출력 값을 배치해야 하는 C 구조체에 대한 포인터입니다.  필수 메서드 중 네 개는 모든 결과가 출력 구조체에 나타나므로 <code class="type">무효만</code> 반환하지만, <code class="function">leaf_consistent는</code> <code class="type">부울</code> 결과를 반환합니다. 이 메서드는 입력 구조체의 어떤 필드도 수정해서는 안 됩니다.  모든 경우에 출력 구조체는 사용자 정의 메서드를 호출하기 전에 0으로 초기화됩니다.  선택적 여섯 번째 메서드 <code class="function">압축은</code>인덱싱할 <code class="type">데이텀을</code> 유일한 인수로 받아들이고 리프 튜플의 물리적 저장에 적합한 값을 반환합니다.  선택적 일곱 번째 메서드 <code class="function">옵션은</code> opclass별 매개변수를 배치해야 하는 C 구조체에 대한 <code class="type">내부</code> 포인터를 허용하고 <code class="type">무효를</code> 반환합니다. </p><p>
  다섯 가지 필수 사용자 정의 메서드는 다음과 같습니다: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">config</code></span></dt><dd><p>
       접두사 및 노드 레이블 데이터 타입의 데이터 타입 OID를 포함하여 인덱스 구현에 대한 정적 정보를 반환합니다.      </p><p>
      함수의 <acronym class="acronym">SQL</acronym> 선언은 다음과 같아야 합니다:</p><pre class="programlisting">
CREATE FUNCTION my_config(internal, internal) RETURNS void ...</pre><p>
      첫 번째 인자는 함수에 대한 입력 데이터를 포함하는 <code class="structname">spgConfigIn</code>C 구조체에 대한 포인터입니다. 두 번째 인자는 함수가 결과 데이터로 채워야 하는 <code class="structname">spgConfigOut</code>C 구조체에 대한 포인터입니다.</p><pre class="programlisting">
typedef 구조체 spgConfigIn { Oid attType; /* 색인할 데이터 타입 */ } spgConfigIn; typedef 구조체 spgConfigOut { Oid prefixType; /* 내부 튜플 접두사의 데이터 타입 */ Oid labelType;      /* 내부 튜플 노드 레이블의 데이터 타입 */ Oid leafType; /* 리프 튜플 값의 데이터 타입 */ bool canReturnData; /* Opclass가 원본 데이터를 재구성할 수 있음 */ bool longValuesOK; /* Opclass가 1 페이지 이상의 값에 대응할 수 있음 */ } spgConfigOut;</pre><p>

     <code class="structfield">attType은</code> 다형성 인덱스 연산자 클래스를 지원하기 위해 전달되며, 일반적인 고정 데이터 타입 연산자 클래스의 경우 항상 동일한 값을 가지므로 무시할 수 있습니다.     </p><p>
      접두사를 사용하지 않는 연산자 클래스의 경우, <code class="structfield">prefixType을</code> <code class="literal">VOIDOID로</code> 설정할 수 있습니다. 마찬가지로, 노드 레이블을 사용하지 않는 연산자 클래스의 경우, <code class="structfield">labelType을</code> <code class="literal">VOIDOID로</code> 설정할 수 있습니다. <code class="structfield">canReturnData는</code> 원래 제공된 인덱스 값을 재구성할 수 있는 연산자 클래스인 경우에만 true로 설정해야 합니다. <code class="structfield">longValuesOK는</code> <code class="structfield">attType의</code> 길이가 다양하고 반복 접미사를 통해 긴 값을 세그먼트화할 수 있는 연산자 클래스인 경우에만 true로 설정합니다( <a class="xref" href="spgist-implementation.html#SPGIST-LIMITS" title="69.4.1. SP-GiST Limits">섹션 69.4.1</a> 참조).     </p><p>
     <code class="structfield">leafType은</code> 연산자 클래스의 <code class="structfield">opckeytype</code>카탈로그 항목에 정의된 인덱스 저장소 유형과 일치해야 합니다. (가장 일반적인 상황인 저장소 유형이 연산자 클래스의 입력 유형과 동일하다는 의미로 <code class="structfield">opckeytype은</code> 0일 수 있습니다.) 이전 버전과의 호환성을 위해 <code class="function">config</code>메서드에서 <code class="structfield">leafType을</code> 다른 값으로 설정하면 해당 값이 사용되지만, 그러면 카탈로그에서 인덱스 내용이 잘못 식별되므로 더 이상 사용되지 않습니다. 또한 <code class="structfield">leafType을</code> 초기화되지 않은 상태(0)로 둘 수 있으며, 이는 <code class="structfield">opckeytype에서</code> 파생된 인덱스 저장 유형을 의미하는 것으로 해석됩니다.     </p><p>
     <code class="structfield">attType과</code> <code class="structfield">leafType이</code> 다른 경우, 선택적 메서드 <code class="function">압축을</code> 제공해야 합니다. 메서드 <code class="function">압축은</code> 인덱싱할 데이터를 <code class="structfield">attType에서</code> <code class="structfield">leafType으로</code> 변환하는 역할을 담당합니다.     </p></dd><dt><span class="term"><code class="function">선택</code></span></dt><dd><p>
        내부 튜플에 새 값을 삽입하는 메서드를 선택합니다.      </p><p>
      함수의 <acronym class="acronym">SQL</acronym> 선언은 다음과 같아야 합니다:</p><pre class="programlisting">
CREATE FUNCTION my_choose(internal, internal) RETURNS void ...</pre><p>
      첫 번째 인자는 함수에 대한 입력 데이터를 포함하는 <code class="structname">spgChooseIn</code>C 구조체에 대한 포인터입니다. 두 번째 인자는 함수가 결과 데이터로 채워야 하는 <code class="structname">spgChooseOut</code>C 구조체에 대한 포인터입니다.</p><pre class="programlisting">
typedef struct spgChooseIn { Datum datum; /* 인덱싱할 원본 데이텀 */ Datum leafDatum; /* 리프에 저장할 현재 데이텀 */ int level; /* 현재 레벨(0부터 카운트) */ /* 현재 내부 튜플의 데이터 */ bool allTheSame; /* 튜플이 모두 동일하게 표시되나요? */ bool hasPrefix; /* 튜플에 접두사가 있나요? */ Datum prefixDatum; /* 그렇다면 접두사 값 */ int nNodes; /* 내부 튜플의 노드 수 */ Datum *nodeLabels; /* 노드 라벨 값 (없는 경우 NULL) */ } spgChooseIn;

typedef enum { spgMatchNode = 1, /* 기존 노드로 하강 */ spgAddNode, /* 내부 튜플에 노드 추가 */ spgSplitTuple /* 내부 튜플 분할 (접두사 변경) */ } spgChooseResultType;

typedef struct spgChooseOut { spgChooseResultType resultType; /* 액션 코드, 위 참조 */ union { struct /* spgMatchNode에 대한 결과 */ { int nodeN;      /* 이 노드로 내려가기 (0에서 인덱스) */ int levelAdd; /* 이만큼 레벨 증가 */ Datum restDatum; /* 새 리프 데이텀 */ } matchNode; struct /* spgAddNode에 대한 결과 */ { Datum nodeLabel;  /* 새 노드의 라벨 */ int nodeN; /* 삽입할 위치 (0부터 인덱스) */ } addNode; struct /* spgSplitTuple에 대한 결과 */ { /* 하나의 자식 튜플을 가진 새로운 상위 레벨 내부 튜플을 형성하는 정보 */ bool prefixHasPrefix; /* 튜플에 접두어가 있어야 하나요? */ 만약 그렇다면, 그 값 */ int prefixNNodes; /* 노드 수 */ Datum *prefixNodeLabels; /* 그들의 레이블 (또는 * 레이블이 없는 경우 NULL) */ int childNodeN; /* 어느 노드가 자식 튜플을 가져올지 */ /* 모든 이전 노드로 새로운 하위 레벨 내부 튜플을 형성하는 정보 */ bool postfixHasPrefix; /* 튜플이 접두사를 가져야 하나요? */ Datum postfixPrefixDatum; /* 만약 그렇다면, 그 값 */ } splitTuple; } result; } spgChooseOut;</pre><p>

      <code class="structfield">datum은</code> 인덱스에 삽입하고자 하는 <code class="structname">spgConfigIn</code><code class="structfield">.attType</code>타입의 원본 데이텀이고, <code class="structfield">leafDatum은</code> 메서드 <code class="function">압축이</code> 제공되면 처음에 메서드 <code class="function">압축이</code> 적용된 결과, 그렇지 않으면 <code class="structfield">datum과</code> 같은 값인 <code class="structname">spgConfigOut</code><code class="structfield">.leafType</code>타입의 값이며, <code class="structfield">leafDatum은</code> <code class="function">선택</code> 또는 <code class="function">picksplit</code>메서드가 변경하면 트리 하위 레벨에서 변경될 수 있습니다.  삽입 검색이 리프 페이지에 도달하면 <code class="structfield">leafDatum의</code> 현재 값은 새로 생성된 리프 튜플에 저장될 값입니다. <code class="structfield">level은</code> 현재 내부 튜플의 레벨로, 루트 레벨의 경우 0부터 시작합니다. 현재 내부 튜플이 여러 개의 동등한 노드를 포함하는 것으로 표시되면 <code class="structfield">allTheSame이</code> 참입니다( <a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="69.4.3. “All-the-Same” Inner Tuples">섹션 69</a> 참조).현재 내부 튜플에 접두사가 포함되어 있으면 <code class="structfield">hasPrefix가</code> 참이고, 접두사가 포함되어 있으면 <code class="structfield">prefixDatum이</code> 그 값입니다. <code class="structfield">nNodes는</code> 내부 튜플에 포함된 자식 노드의 수이고 <code class="structfield">nodeLabels는</code> 해당 라벨 값의 배열, 라벨이 없는 경우 NULL입니다.      </p><p>
      <code class="function">선택</code> 함수는 새 값이 기존 자식 노드 중 하나와 일치하는지, 새 자식 노드를 추가해야 하는지, 새 값이 튜플 접두사와 일치하지 않으므로 내부 튜플을 분할하여 덜 제한적인 접두사를 만들어야 하는지 판단할 수 있습니다.      </p><p>
       새 값이 기존 자식 노드 중 하나와 일치하는 경우 <code class="structfield">resultType을</code> <code class="literal">spgMatchNode로</code> 설정합니다. 노드 배열에서 해당 노드의 인덱스(0부터)로 <code class="structfield">nodeN을</code> 설정합니다. 해당 노드를 통해 내려가면서 발생하는 <code class="structfield">레벨</code> 증가분에 <code class="structfield">levelAdd를</code> 설정하거나 연산자 클래스에서 레벨을 사용하지 않는 경우 0으로 남겨둡니다. 연산자 클래스에서 한 레벨에서 다음 레벨로 데이텀을 수정하지 않으면 <code class="structfield">restDatum을</code> <code class="structfield">leafDatum과</code>동일하게 설정하거나 다음 레벨에서 <code class="structfield">leafDatum으로</code> 사용될 수정 값으로 설정합니다.      </p><p>
       새 자식 노드를 추가해야 하는 경우 <code class="structfield">resultType을</code> <code class="literal">spgAddNode로</code> 설정합니다. 새 노드에 사용할 레이블로 <code class="structfield">nodeLabel을</code> 설정하고 노드 배열에서 노드를 삽입할 인덱스(0부터)로 <code class="structfield">nodeN을</code> 설정합니다. 노드가 추가된 후 수정된 내부 튜플로 <code class="function">select</code>함수가 다시 호출되며 이 호출은 <code class="literal">spgMatchNode</code> 결과를 가져와야 합니다.      </p><p>
       새 값이 튜플 접두사와 일치하지 않으면 <code class="structfield">결과 유형을</code> <code class="literal">spgSplitTuple로</code> 설정합니다. 이 작업은 모든 기존 노드를 새로운 하위 수준 내부 튜플로 이동하고 기존 내부 튜플을 새로운 하위 수준 내부 튜플을 가리키는 단일 다운링크가 있는 튜플로 대체합니다. 새로운 상위 튜플에 접두사가 있어야 하는지 여부를 나타내도록 <code class="structfield">prefixHasPrefix를</code> 설정하고, 있다면 접두사 값에 <code class="structfield">prefixPrefixDatum을</code> 설정합니다.  이 새 접두사 값은 색인될 새 값을 허용하기 위해 원본보다 충분히 덜 제한적이어야 합니다. <code class="structfield">prefixNNodes를</code> 새 튜플에 필요한 노드 수로 설정하고 <code class="structfield">prefixNodeLabels를</code> 해당 노드의 레이블이 포함된 palloc'd 배열로 설정하거나 노드 레이블이 필요하지 않은 경우 NULL로 설정합니다.
       새 상위 튜플의 총 크기는 대체하는 튜플의 총 크기보다 작아야 하며, 이는 새 접두사와 새 레이블의 길이를 제한합니다. <code class="structfield">childNodeN을</code> 새 하위 수준 내부 튜플에 다운링크할 노드의 인덱스(0부터)로 설정합니다. <code class="structfield">postfixHasPrefix를</code> 설정하여 새 하위 수준 내부 튜플에 접두사가 있어야 하는지 여부를 나타내며, 있는 경우 <code class="structfield">postfixPrefixDatum을</code> 접두사 값으로 설정합니다.  이 두 접두사와 다운링크 노드의 레이블(있는 경우)의 조합은 원래 접두사와 동일한 의미를 가져야 합니다. 새로운 하위 수준 튜플로 이동되는 노드 레이블을 변경하거나 하위 인덱스 항목을 변경할 수 없기 때문입니다. 노드가 분할된 후에는 대체 내부 튜플로 <code class="function">choose</code>함수가 다시 호출됩니다. 이 호출은 <code class="literal">spgSplitTuple</code> 작업에 의해 적합한 노드가 생성되지 않은 경우 <code class="literal">spgAddNode</code> 결과를 반환할 수 있습니다.  결국 <code class="function">선택</code> 함수는 삽입이 다음 단계로 내려가도록 허용하기 위해 <code class="literal">spgMatchNode를</code> 반환해야 합니다.      </p></dd><dt><span class="term"><code class="function">picksplit</code></span></dt><dd><p>
       리프 튜플 집합 위에 새 내부 튜플을 만드는 방법을 결정합니다.      </p><p>
        함수의 <acronym class="acronym">SQL</acronym> 선언은 다음과 같아야 합니다:</p><pre class="programlisting">
CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ...</pre><p>
      첫 번째 인자는 함수에 대한 입력 데이터를 포함하는 <code class="structname">spgPickSplitIn</code>C 구조체에 대한 포인터입니다. 두 번째 인자는 함수가 결과 데이터로 채워야 하는 <code class="structname">spgPickSplitOut</code>C 구조체에 대한 포인터입니다.</p><pre class="programlisting">
typedef struct spgPickSplitIn { int nTuples; /* 리프 튜플 수 */ Datum *datums; /* 이들의 데이텀(길이 nTuples의 배열) */ int level; /* 현재 레벨(0부터 카운트) */ } spgPickSplitIn; typedef struct spgPickSplitOut { bool hasPrefix; /* 새 내부 튜플에는 접두사가 있어야 하나요? */ Datum prefixDatum; /* 만약 그렇다면, 그 값 */ int nNodes; /* 새 내부 튜플의 노드 수 */ Datum *nodeLabels; /* 그들의 라벨 (또는 라벨이 없는 경우 NULL) */ int *mapTuplesToNodes; /* 각 리프 튜플의 노드 인덱스 */ Datum *leafTupleDatums; /* 각 새 리프 튜플에 저장할 데이터텀 */ } spgPickSplitOut;</pre><p>

      <code class="structfield">nTuples는</code> 제공된 리프 튜플의 수입니다. <code class="structfield">datums는</code> <code class="structname">spgConfigOut</code><code class="structfield">.leafType</code>유형의 데이텀 값의 배열입니다. <code class="structfield">level은</code> 모든 리프 튜플이 공유하는 현재 레벨로, 새 내부 튜플의 레벨이 됩니다.      </p><p>
      <code class="structfield">hasPrefix를</code> 설정하여 새 내부 튜플에 접두사가 있어야 하는지 여부를 나타내고 접두사가 있는 경우 <code class="structfield">prefixDatum을</code> 접두사 값으로 설정합니다. <code class="structfield">nNodes를</code> 설정하여 새 내부 튜플에 포함될 노드 수를 나타내고 <code class="structfield">nodeLabels를</code> 해당 레이블 값의 배열로 설정하거나 노드 레이블이 필요하지 않은 경우 NULL로 설정합니다. <code class="structfield">mapTuplesToNodes를</code> 각 리프 튜플이 할당될 노드의 색인(0부터)을 제공하는 배열로 설정합니다.
      <code class="structfield">leafTupleDatums를</code> 새 리프 튜플에 저장할 값의 배열로 설정합니다(연산자 클래스가 한 수준에서 다음 수준으로 데이텀을 수정하지 않으면 입력 <code class="structfield">데이텀과</code> 동일합니다). <code class="function">picksplit</code> 함수는 <code class="structfield">nodeLabels</code>, <code class="structfield">mapTuplesToNodes</code> 및 <code class="structfield">leafTupleDatums</code> 배열을 팔로잉하는 일을 담당한다는 점에 유의하세요.      </p><p>
       두 개 이상의 리프 튜플이 제공되면 <code class="function">picksplit</code> 함수가 이를 둘 이상의 노드로 분류하고, 그렇지 않으면 이 작업의 궁극적인 목적인 리프 튜플을 여러 페이지에 걸쳐 분할할 수 없습니다.  따라서 <code class="function">픽스플릿</code> 함수가 모든 리프 튜플을 동일한 노드에 배치하게 되면 핵심 SP-GiST 코드는 이 결정을 무시하고 리프 튜플이 동일하게 레이블이 지정된 여러 노드에 무작위로 할당되는 내부 튜플을 생성합니다.  이러한 튜플은 <code class="literal">모두 동일하게</code> 표시되어 이런 일이 발생했음을 나타냅니다. <code class="function">choose</code> 함수와 <code class="function">inner_consistent</code> 함수는 이러한 내부 튜플에 대해 적절한 주의를 기울여야 합니다. 자세한 내용은 <a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="69.4.3. “All-the-Same” Inner Tuples">69.4.3절을</a> 참조하세요.      </p><p>
      <code class="function">config</code> 함수가 <code class="structfield">longValuesOK를</code> true로 설정하고 한 페이지보다 큰 입력 값이 제공된 경우에만 단일 리프 튜플에 <code class="function">picksplit을</code> 적용할 수 있습니다.  이 경우 작업의 요점은 접두사를 제거하고 더 짧은 새 리프 데이텀 값을 생성하는 것입니다. 이 호출은 페이지에 맞을 만큼 짧은 리프 데이텀이 생성될 때까지 반복됩니다.  자세한 내용은 <a class="xref" href="spgist-implementation.html#SPGIST-LIMITS" title="69.4.1. SP-GiST Limits">섹션 69.4.1을</a> 참조하세요.      </p></dd><dt><span class="term"><code class="function">inner_consistent</code></span></dt><dd><p>
       트리 검색 중에 따라야 할 노드(브랜치) 집합을 반환합니다.      </p><p>
       함수의 <acronym class="acronym">SQL</acronym> 선언은 다음과 같아야 합니다:</p><pre class="programlisting">
CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ...</pre><p>
      첫 번째 인자는 함수에 대한 입력 데이터를 포함하는 <code class="structname">spgInnerConsistentIn</code>C 구조체에 대한 포인터입니다. 두 번째 인자는 함수가 결과 데이터로 채워야 하는 <code class="structname">spgInnerConsistentOut</code>C 구조체에 대한 포인터입니다.</p><pre class="programlisting">
typedef struct spgInnerConsistentIn { ScanKey scankeys; /* 연산자 및 비교값 배열 */ ScanKey orderbys; /* 순서 연산자 및 비교 *값 배열 */ int nkeys; /* scankeys 배열의 길이 */ int norderbys;      /* orderbys 배열의 길이 */ 데이텀 재구성값; /* 부모에서 재구성된 값 */ void *트래버스값; /* 옵클래스별 트래버스값 */ 메모리컨텍스트 트래버스메모리컨텍스트; /* 여기에 새 트래버스값 넣기 */ int 레벨; /* 현재 레벨 (0부터 카운트) */ bool 반환데이터; /* 원본 데이터를 반환해야 하나요? */ /* 현재 내부 튜플의 데이터 */ bool allTheSame; /* 튜플이 모두 동일하게 표시되어 있나요? */ bool hasPrefix; /* 튜플에 접두사가 있나요? */ Datum prefixDatum; /* 만약 그렇다면, 접두사 값 */ int nNodes; /* 내부 튜플의 노드 수 */ Datum *nodeLabels; /* 노드 라벨 값 (없는 경우 NULL) */ } spgInnerConsistentIn; typedef struct spgInnerConsistentOut { int nNodes; /* 방문해야 할 하위 노드의 수 */ int *nodeNumbers;    /* 노드 배열 내 그들의 인덱스 */ int *levelAdds; /* 각각에 대해 이만큼 레벨을 증가 */ Datum *재구성값; /* 연관된 재구성값 */ void **traversalValues; /* 옵클래스별 트래버스값 */ double **distances; /* 연관된 거리 */ } spgInnerConsistentOut;</pre><p>

       길이가 <code class="structfield">nkeys인</code> 배열 <code class="structfield">scankeys는</code> 인덱스 검색 조건을 설명합니다.  이러한 조건은 AND와 결합되며, 모든 조건을 만족하는 인덱스 항목만 흥미롭습니다.  ( <code class="structfield">nkeys</code> = 0은 모든 인덱스 항목이 쿼리를 만족한다는 의미입니다.)  일반적으로 일관된 함수는 각 배열 항목의 <code class="structfield">sk_strategy</code> 및 <code class="structfield">sk_argument</code> 필드에만 관심을 가지며, 각각 인덱싱 가능한 연산자와 비교 값을 제공합니다. 특히 SP-GiST 코어 코드가 이러한 조건을 필터링하므로 비교 값이 NULL인지 확인하기 위해 <code class="structfield">sk_flags를</code> 확인할 필요가 없습니다. 길이 <code class="structfield">norderbys의</code> 배열 <code class="structfield">orderbys도</code> 같은 방식으로 순서 연산자(있는 경우)를 설명합니다.
      <code class="structfield">reconstructedValue는</code> 부모 튜플에 대해 재구성된 값으로, 루트 수준에서 <code class="literal">(Datum) 0이거나</code>, <code class="function">내부 일관성</code> 함수가 부모 수준에서 값을 제공하지 않은 경우입니다. <code class="structfield">traversalValue는</code> 부모 인덱스 튜플의 이전 <code class="function">inner_consistent</code>호출에서 전달된 모든 트래버스 데이터에 대한 포인터 또는 루트 수준에서 NULL이 됩니다.
      <code class="structfield">traversalMemoryContext는</code> 출력 트래버스 값을 저장할 메모리 컨텍스트입니다(아래 참조). <code class="structfield">level은</code> 루트 레벨의 경우 0부터 시작하는 현재 내부 튜플의 레벨입니다. <code class="structfield">returnData는</code> 이 쿼리에 재구성된 데이터가 필요한 경우 <code class="literal">참이며</code>, <code class="function">구성</code> 함수에서 <code class="structfield">canReturnData를</code> 어설트한 경우에만 해당됩니다.
      <code class="structfield">allTheSame은</code> 현재 내부 튜플이 <span class="quote">"<span class="quote">모두 동일</span>"</span>으로 표시된 경우 참입니다. 이 경우 모든 노드가 동일한 레이블(있는 경우)을 가지므로 모든 노드가 쿼리와 일치하거나 일치하지 않습니다( <a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="69.4.3. “All-the-Same” Inner Tuples">69.4.3절</a> 참조). <code class="structfield">hasPrefix는</code> 현재 내부 튜플에 접두사가 포함되어 있으면 참이고, 있다면 <code class="structfield">prefixDatum이</code> 그 값입니다. <code class="structfield">nNodes는</code> 내부 튜플에 포함된 하위 노드의 수이고 <code class="structfield">nodeLabels는</code> 해당 레이블 값의 배열 또는 노드에 레이블이 없는 경우 NULL입니다.      </p><p>
      <code class="structfield">nNodes는</code> 검색에서 방문해야 하는 자식 노드의 수로 설정해야 하며, <code class="structfield">nodeNumbers는</code> 해당 인덱스의 배열로 설정해야 합니다. 연산자 클래스가 레벨을 추적하는 경우, 방문할 각 노드로 내려갈 때 필요한 레벨 증분의 배열에 <code class="structfield">levelAdds를</code> 설정합니다.  (종종 이러한 증분은 모든 노드에 대해 동일하지만 반드시 그런 것은 아니므로 배열이 사용됩니다.) 값 재구성이 필요한 경우, 방문할 각 하위 노드에 대해 재구성된 값의 배열로 <code class="structfield">reconstructedValues를</code> 설정하고, 그렇지 않으면 <code class="structfield">reconstructedValues를</code> NULL로 둡니다. 재구성된 값은 <code class="structname">spgConfigOut</code> 유형으로 가정합니다.(그러나 코어 시스템에서는 복사하는 것 외에는 아무 작업도 수행하지 않으므로 <code class="structfield">leafType과</code> 동일한 <code class="literal">유형</code> 및 <code class="literal">유형별</code>속성을 가지면 충분합니다.) 정렬 검색이 수행되는 경우 <code class="structfield">거리를</code> <code class="structfield">orderbys</code>배열에 따른 거리 값 배열로 설정합니다(거리가 가장 낮은 노드가 먼저 처리됩니다).  그렇지 않으면 NULL로 둡니다. 트리 검색의 하위 레벨에 추가 대역 외 정보("<span class="quote"><span class="quote">트래버스 값</span></span>")를 전달하려면 방문할 하위 노드마다 하나씩 적절한 트래버스 값의 배열로 <code class="structfield">traversalValues를</code> 설정하고, 그렇지 않으면 <code class="structfield">traversalValues를</code> NULL로 둡니다.
      <code class="function">내부 일관성</code> 함수는 현재 메모리 컨텍스트에서 <code class="structfield">nodeNumbers</code>, <code class="structfield">levelAdds</code>, <code class="structfield">distances</code>, <code class="structfield">reconstructedValues</code> 및 <code class="structfield">traversalValues</code> 배열을 팔로잉하는 역할을 합니다. 그러나 <code class="structfield">traversalValues</code> 배열이 가리키는 모든 출력 트래버스 값은 <code class="structfield">traversalMemoryContext에</code> 할당되어야 합니다. 각 트래버스 값은 팔로잉된 단일 청크여야 합니다.      </p></dd><dt><span class="term"><code class="function">leaf_consistent</code></span></dt><dd><p>
       리프 튜플이 쿼리를 만족하면 참을 반환합니다.      </p><p>
       함수의 <acronym class="acronym">SQL</acronym> 선언은 다음과 같아야 합니다:</p><pre class="programlisting">
CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ...</pre><p>
      첫 번째 인자는 함수에 대한 입력 데이터를 포함하는 <code class="structname">spgLeafConsistentIn</code>C 구조체에 대한 포인터입니다. 두 번째 인자는 함수가 결과 데이터로 채워야 하는 <code class="structname">spgLeafConsistentOut</code>C 구조체에 대한 포인터입니다.</p><pre class="programlisting">
typedef struct spgLeafConsistentIn { ScanKey scankeys; /* 연산자 및 비교값 배열 */ ScanKey orderbys; /* 순서 연산자 및 비교 *값 배열 */ int nkeys; /* scankeys 배열의 길이 */ int norderbys;      /* orderbys 배열의 길이 */ Datum reconstructedValue; /* 부모에서 재구성된 값 */ void *traversalValue; /* 옵클래스별 트래버스 값 */ int level; /* 현재 레벨 (0부터 계산) */ bool returnData; /* 원본 데이터를 반환해야 하나요? */ Datum leafDatum; /* 리프 튜플의 데이텀 */ } spgLeafConsistentIn; typedef struct spgLeafConsistentOut { Datum leafValue; /* 재구성된 원본 데이터, 있는 경우 */ bool recheck; /* 연산자를 다시 확인해야 한다면 true 설정 */ bool recheckDistances; /* 거리를 다시 확인해야 한다면 true 설정 */ double *distances; /* 연결된 거리 */ } spgLeafConsistentOut;</pre><p>

       길이가 <code class="structfield">nkeys인</code> 배열 <code class="structfield">scankeys는</code> 인덱스 검색 조건을 설명합니다.  이러한 조건은 AND와 결합되어 모든 조건을 만족하는 인덱스 항목만 쿼리를 충족합니다.  ( <code class="structfield">nkeys</code> = 0은 모든 인덱스 항목이 쿼리를 만족한다는 의미입니다.)  일반적으로 일관성 함수는 각 배열 항목의 <code class="structfield">sk_strategy</code> 및 <code class="structfield">sk_argument</code> 필드에만 관심을 가지며, 각각 인덱싱 가능한 연산자와 비교 값을 제공합니다. 특히 SP-GiST 코어 코드가 이러한 조건을 필터링하기 때문에 비교 값이 NULL인지 확인하기 위해 <code class="structfield">sk_flags를</code> 확인할 필요가 없습니다.
       길이가 <code class="structfield">norderbys인</code> array <code class="structfield">orderbys도</code> 같은 방식으로 순서 연산자를 설명합니다. <code class="structfield">reconstructedValue는</code> 부모 튜플에 대해 재구성된 값으로, 루트 수준에서 <code class="literal">(Datum) 0이거나</code> <code class="function">내부 일관성</code> 함수가 부모 수준에서 값을 제공하지 않은 경우입니다.
      <code class="structfield">traversalValue는</code> 부모 인덱스 튜플의 이전 <code class="function">inner_consistent</code>호출에서 전달된 모든 트래버스 데이터에 대한 포인터이거나 루트 레벨에서는 NULL입니다. <code class="structfield">level은</code> 현재 리프 튜플의 레벨로, 루트 레벨의 경우 0부터 시작합니다. <code class="structfield">returnData는</code> 이 쿼리에 재구성된 데이터가 필요한 경우 <code class="literal">true이며</code>, 이는 <code class="function">구성</code> 함수가 <code class="structfield">canReturnData를</code> 어서트한 경우에만 해당됩니다. <code class="structfield">leafDatum은</code> 현재 리프 튜플에 저장된 <code class="structname">spgConfigOut</code><code class="structfield">.leafType의</code>키 값입니다.      </p><p>
       이 함수는 리프 튜플이 쿼리와 일치하면 <code class="literal">참을</code> 반환하고, 일치하지 않으면 <code class="literal">거짓을</code> 반환해야 합니다. <code class="literal">참인</code> 경우, <code class="structfield">반환데이터가</code> <code class="literal">참이면</code> 이 리프 튜플에 대한 인덱싱을 위해 원래 제공된 값( <code class="structname">spgConfigIn</code><code class="structfield">.attType</code> 유형)으로 <code class="structfield">leafValue를</code> 설정해야 합니다.  또한 일치 여부가 불확실하여 실제 힙 튜플에 연산자를 다시 적용하여 일치 여부를 확인해야 하는 경우 <code class="structfield">재검사를</code> <code class="literal">true로</code> 설정할 수 있습니다. 정렬 검색이 수행되는 경우 <code class="structfield">거리를</code> <code class="structfield">orderbys</code>배열에 따른 거리 값 배열로 설정합니다.  그렇지 않으면 NULL로 둡니다.  반환된 거리 중 하나 이상이 정확하지 않은 경우 <code class="structfield">recheckDistances를</code> true로 설정합니다. 이 경우 실행자는 힙에서 튜플을 가져온 후 정확한 거리를 계산하고 필요한 경우 튜플을 다시 정렬합니다.      </p></dd></dl></div><p>
  선택적 사용자 정의 메서드는 다음과 같습니다: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">데이텀 압축(데이텀 인)</code></span></dt><dd><p>
       데이터 항목을 인덱스의 리프 튜플에 물리적으로 저장하기에 적합한 형식으로 변환합니다.  이 메서드는 <code class="structname">spgConfigIn</code><code class="structfield">.attType</code>타입의 값을 받아들이고 <code class="structname">spgConfigOut</code><code class="structfield">.leafType</code> 타입의 값을 반환합니다. 출력 값에는 라인 밖의 TOAST 포인터가 포함되어서는 안 됩니다.      </p><p>
       참고: <code class="function">압축</code> 메서드는 저장할 값에만 적용됩니다.  일관된 메서드는 <code class="function">압축을</code> 사용한 변환 없이 쿼리 <code class="structfield">스캥키를</code> 변경 없이 수신합니다.      </p></dd><dt><span class="term"><code class="function">옵션</code></span></dt><dd><p>
       연산자 클래스 동작을 제어하는 사용자 표시 매개변수 집합을 정의합니다.      </p><p>
        함수의 <acronym class="acronym">SQL</acronym> 선언은 다음과 같아야 합니다:</p><pre class="programlisting">
CREATE OR REPLACE FUNCTION my_options(internal) RETURNS void AS 'MODULE_PATHNAME' LANGUAGE C STRICT;</pre><p>
      </p><p>
       이 함수에는 연산자 클래스별 옵션 집합으로 채워야 하는 <code class="structname">local_relopts</code>구조체에 대한 포인터가 전달됩니다.  이 옵션은 <code class="literal">PG_HAS_OPCLASS_OPTIONS()</code> 및 <code class="literal">PG_GET_OPCLASS_OPTIONS()</code> 매크로를 사용하여 다른 지원 함수에서 액세스할 수 있습니다.      </p><p>
      <acronym class="acronym">SP-GiST에서</acronym> 키의 표현은 유연하기 때문에 사용자가 지정한 매개변수에 따라 달라질 수 있습니다.      </p></dd></dl></div><p>
   모든 SP-GiST 지원 메서드는 일반적으로 수명이 짧은 메모리 컨텍스트에서 호출되며, 즉 각 튜플을 처리한 후 <code class="varname">CurrentMemoryContext가</code> 리셋됩니다.  따라서 팔로록한 모든 것을 해제하는 것에 대해 걱정할 필요는 없습니다.  ( <code class="function">구성</code>메서드는 예외입니다. 메모리 누수를 피하려고 노력해야 합니다.  하지만 일반적으로 <code class="function">구성</code> 메서드는 전달된 매개변수 구조체에 상수를 할당하는 것 외에는 아무것도 하지 않아도 됩니다).  </p><p>
   인덱싱된 컬럼이 콜레이션 가능한 데이터 타입인 경우, 인덱스 콜레이션은 표준 <code class="function">PG_GET_COLLATION()</code> 메커니즘을 사용하여 모든 지원 메서드에 전달됩니다.  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spgist-builtin-opclasses.html" title="69.2. Built-in Operator Classes">이전</a> </td><td width="20%" align="center"><a accesskey="u" href="spgist.html" title="Chapter 69. SP-GiST Indexes">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="spgist-implementation.html" title="69.4. Implementation">다음</a></td></tr><tr><td width="40%" align="left" valign="top">69.2. 내장 연산자 클래스 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 16.2 Documentation">홈</a></td><td width="40%" align="right" valign="top"> 69.4. 구현</td></tr></table></div></body></html>